This Source Code Form is subject to the terms of the Mozilla Public
License, v. 2.0. If a copy of the MPL was not distributed with this file,
You can obtain one at https://mozilla.org/MPL/2.0/.

Copyright (c) 2019, The Brave Authors
Copyright (c) 2025, The Helium Authors

Alternatively, the contents of this file may be used under the terms
of the GNU General Public License Version 3, as described below:

Copyright (C) 2025 The Helium Authors

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.

--- /dev/null
+++ b/chrome/browser/importer/chrome_importer_list.cc
@@ -0,0 +1,161 @@
+/* Copyright (c) 2019 The Brave Authors, 2025 imput. All rights reserved.
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this file,
+ * You can obtain one at https://mozilla.org/MPL/2.0/. */
+
+#include "chrome/browser/importer/importer_list.h"
+
+#include "base/check.h"
+#include "base/files/file_path.h"
+#include "base/strings/strcat.h"
+#include "base/strings/utf_string_conversions.h"
+#include "base/threading/scoped_blocking_call.h"
+#include "base/values.h"
+#include "chrome/common/importer/chrome_importer_utils.h"
+#include "chrome/common/importer/importer_constants.h"
+#include "chrome/grit/generated_resources.h"
+#include "components/user_data_importer/common/importer_type.h"
+#include "ui/base/l10n/l10n_util.h"
+
+namespace {
+void AddChromeToProfiles(
+    std::vector<user_data_importer::SourceProfile>* profiles,
+    base::Value::List chrome_profiles,
+    const base::FilePath& user_data_folder,
+    const std::string& brand,
+    user_data_importer::ImporterType type) {
+  for (const auto& value : chrome_profiles) {
+    const auto* dict = value.GetIfDict();
+    if (!dict) {
+      continue;
+    }
+    uint16_t items = user_data_importer::NONE;
+    auto* profile = dict->FindString("id");
+    auto* name = dict->FindString("name");
+    DCHECK(profile);
+    DCHECK(name);
+    base::FilePath path = user_data_folder;
+    if (!ChromeImporterCanImport(path.Append(base::FilePath::StringType(
+                                     profile->begin(), profile->end())),
+                                 type, &items)) {
+      continue;
+    }
+    user_data_importer::SourceProfile chrome;
+    chrome.importer_name = base::UTF8ToUTF16(brand);
+    chrome.importer_type = type;
+    chrome.services_supported = items;
+    chrome.source_path = user_data_folder.Append(
+        base::FilePath::StringType(profile->begin(), profile->end()));
+    chrome.profile = base::UTF8ToUTF16(*name);
+    profiles->push_back(chrome);
+  }
+}
+
+void DetectChromeProfiles(
+    std::vector<user_data_importer::SourceProfile>* profiles) {
+  base::ScopedBlockingCall scoped_blocking_call(FROM_HERE,
+                                                base::BlockingType::WILL_BLOCK);
+  AddChromeToProfiles(
+      profiles,
+      GetChromeSourceProfiles(GetChromeUserDataFolder().Append(
+          base::FilePath::StringType(FILE_PATH_LITERAL("Local State")))),
+      GetChromeUserDataFolder(), kGoogleChromeBrowser,
+      user_data_importer::TYPE_CHROME);
+  AddChromeToProfiles(
+      profiles,
+      GetChromeSourceProfiles(GetChromeBetaUserDataFolder().Append(
+          base::FilePath::StringType(FILE_PATH_LITERAL("Local State")))),
+      GetChromeBetaUserDataFolder(), kGoogleChromeBrowserBeta,
+      user_data_importer::TYPE_CHROME);
+  AddChromeToProfiles(
+      profiles,
+      GetChromeSourceProfiles(GetChromeDevUserDataFolder().Append(
+          base::FilePath::StringType(FILE_PATH_LITERAL("Local State")))),
+      GetChromeDevUserDataFolder(), kGoogleChromeBrowserDev,
+      user_data_importer::TYPE_CHROME);
+#if !BUILDFLAG(IS_LINUX)
+  AddChromeToProfiles(
+      profiles,
+      GetChromeSourceProfiles(GetCanaryUserDataFolder().Append(
+          base::FilePath::StringType(FILE_PATH_LITERAL("Local State")))),
+      GetCanaryUserDataFolder(), kGoogleChromeBrowserCanary,
+      user_data_importer::TYPE_CHROME);
+
+  AddChromeToProfiles(
+      profiles,
+      GetChromeSourceProfiles(GetArcUserDataFolder().Append(
+          base::FilePath::StringType(FILE_PATH_LITERAL("Local State")))),
+      GetArcUserDataFolder(), kArcBrowser, user_data_importer::TYPE_ARC);
+#endif
+#if BUILDFLAG(IS_MAC)
+  AddChromeToProfiles(
+      profiles,
+      GetChromeSourceProfiles(GetDiaUserDataFolder().Append(
+          base::FilePath::StringType(FILE_PATH_LITERAL("Local State")))),
+      GetDiaUserDataFolder(), kDiaBrowser, user_data_importer::TYPE_DIA);
+#endif
+#if BUILDFLAG(IS_WIN) || BUILDFLAG(IS_MAC)
+  AddChromeToProfiles(
+      profiles,
+      GetChromeSourceProfiles(GetCometUserDataFolder().Append(
+          base::FilePath::StringType(FILE_PATH_LITERAL("Local State")))),
+      GetCometUserDataFolder(), kPerplexityCometBrowser, user_data_importer::TYPE_PERPLEXITY_COMET);
+#endif
+  AddChromeToProfiles(
+      profiles,
+      GetChromeSourceProfiles(GetChromiumUserDataFolder().Append(
+          base::FilePath::StringType(FILE_PATH_LITERAL("Local State")))),
+      GetChromiumUserDataFolder(), kChromiumBrowser,
+      user_data_importer::TYPE_CHROME);
+
+  AddChromeToProfiles(
+      profiles,
+      GetChromeSourceProfiles(GetEdgeUserDataFolder().Append(
+          base::FilePath::StringType(FILE_PATH_LITERAL("Local State")))),
+      GetEdgeUserDataFolder(), kMicrosoftEdgeBrowser,
+      user_data_importer::TYPE_EDGE_CHROMIUM);
+
+  AddChromeToProfiles(
+      profiles,
+      GetChromeSourceProfiles(GetVivaldiUserDataFolder().Append(
+          base::FilePath::StringType(FILE_PATH_LITERAL("Local State")))),
+      GetVivaldiUserDataFolder(), kVivaldiBrowser,
+      user_data_importer::TYPE_VIVALDI);
+
+  AddChromeToProfiles(
+      profiles,
+      GetChromeSourceProfiles(GetOperaUserDataFolder().Append(
+          base::FilePath::StringType(FILE_PATH_LITERAL("Local State")))),
+      GetOperaUserDataFolder(), kOperaBrowser, user_data_importer::TYPE_OPERA);
+
+  AddChromeToProfiles(
+      profiles,
+      GetChromeSourceProfiles(GetYandexUserDataFolder().Append(
+          base::FilePath::StringType(FILE_PATH_LITERAL("Local State")))),
+      GetYandexUserDataFolder(), kYandexBrowser,
+      user_data_importer::TYPE_YANDEX);
+
+  AddChromeToProfiles(
+      profiles,
+      GetChromeSourceProfiles(GetWhaleUserDataFolder().Append(
+          base::FilePath::StringType(FILE_PATH_LITERAL("Local State")))),
+      GetWhaleUserDataFolder(), kWhaleBrowser, user_data_importer::TYPE_WHALE);
+
+  AddChromeToProfiles(
+    profiles,
+    GetChromeSourceProfiles(GetBraveUserDataFolder().Append(
+        base::FilePath::StringType(FILE_PATH_LITERAL("Local State")))),
+    GetBraveUserDataFolder(), kBraveBrowser, user_data_importer::TYPE_BRAVE);
+
+#if BUILDFLAG(IS_LINUX)
+  // Installed via snap Opera has different profile path.
+  AddChromeToProfiles(
+      profiles,
+      GetChromeSourceProfiles(GetOperaSnapUserDataFolder().Append(
+          base::FilePath::StringType(FILE_PATH_LITERAL("Local State")))),
+      GetOperaSnapUserDataFolder(), kOperaBrowser,
+      user_data_importer::TYPE_OPERA);
+#endif
+}
+
+}  // namespace
--- /dev/null
+++ b/chrome/common/importer/chrome_importer_utils.cc
@@ -0,0 +1,243 @@
+/* Copyright (c) 2019 The Brave Authors, 2025 imput. All rights reserved.
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this file,
+ * You can obtain one at https://mozilla.org/MPL/2.0/. */
+
+#include "chrome/common/importer/chrome_importer_utils.h"
+
+#include <memory>
+#include <optional>
+#include <utility>
+
+#include "base/check.h"
+#include "base/files/file_path.h"
+#include "base/files/file_util.h"
+#include "base/json/json_reader.h"
+#include "base/values.h"
+#include "chrome/common/importer/importer_constants.h"
+#include "chrome/common/importer/scoped_copy_file.h"
+#include "components/user_data_importer/common/importer_data_types.h"
+#include "components/webdata/common/webdata_constants.h"
+#include "sql/database.h"
+#include "sql/statement.h"
+
+#if BUILDFLAG(ENABLE_EXTENSIONS)
+#include "extensions/common/extension.h"
+#include "extensions/common/manifest.h"
+#endif
+
+#if BUILDFLAG(ENABLE_EXTENSIONS)
+using extensions::Extension;
+using extensions::Manifest;
+#endif
+
+namespace {
+#if BUILDFLAG(ENABLE_EXTENSIONS)
+
+std::optional<base::Value::Dict> GetChromeExtensionsListFromFile(
+    const base::FilePath& preference_path) {
+  if (!base::PathExists(preference_path))
+    return std::nullopt;
+
+  std::string preference_content;
+  base::ReadFileToString(preference_path, &preference_content);
+
+  std::optional<base::Value::Dict> preference =
+      base::JSONReader::ReadDict(preference_content,
+                                 base::JSON_PARSE_CHROMIUM_EXTENSIONS);
+  if (!preference) {
+    return std::nullopt;
+  }
+  if (auto* extensions =
+          preference->FindDictByDottedPath(kChromeExtensionsListPath)) {
+    return std::move(*extensions);
+  }
+  return std::nullopt;
+}
+
+bool HasImportableExtensions(const base::FilePath& profile_path) {
+  return GetImportableChromeExtensionsList(profile_path).has_value();
+}
+
+std::vector<std::string> GetImportableListFromChromeExtensionsList(
+    const base::Value::Dict& extensions_list) {
+  std::vector<std::string> extensions;
+  for (const auto [key, value] : extensions_list) {
+    if (!value.is_dict()) {
+      continue;
+    }
+    const base::Value::Dict& dict = value.GetDict();
+    // Only import if type is extension, it's came from webstore and it's not
+    // installed by default.
+    if (dict.FindBool("was_installed_by_default").value_or(true))
+      continue;
+
+    const auto state = dict.FindInt("state");
+    if (state.has_value()) {
+      // If `state` exists, probably it is an old browser version.
+      if (state == 0) {
+        // explicit `"state": 0` means disabled state
+        continue;
+      }
+    } else if (const auto* disable_reasons = dict.FindList("disable_reasons");
+               disable_reasons && !disable_reasons->empty()) {
+      // For new browsers an extension is enabled if there is no disable reason.
+      continue;
+    }
+
+    if (!dict.FindBool("from_webstore").value_or(false)) {
+      continue;
+    }
+
+    if (auto* manifest_dict = dict.FindDict("manifest")) {
+      if (Manifest::GetTypeFromManifestValue(*manifest_dict) ==
+          Manifest::TYPE_EXTENSION) {
+        extensions.push_back(key);
+      }
+    }
+  }
+
+  return extensions;
+}
+
+std::optional<base::Value::Dict> GetChromeExtensionsList(
+    const base::FilePath& profile_path) {
+  auto list_from_secure_preference = GetChromeExtensionsListFromFile(
+      profile_path.AppendASCII(kChromeSecurePreferencesFile));
+
+  auto list_from_preferences = GetChromeExtensionsListFromFile(
+      profile_path.AppendASCII(kChromePreferencesFile));
+  if (!list_from_secure_preference.has_value())
+    return list_from_preferences;
+
+  if (list_from_secure_preference.has_value() &&
+      list_from_preferences.has_value()) {
+    list_from_secure_preference->Merge(
+        std::move(list_from_preferences.value()));
+    return list_from_secure_preference;
+  }
+
+  return list_from_secure_preference;
+}
+#endif
+
+bool IsLastActiveProfile(const std::string& profile,
+                         const base::Value::List& last_active_profiles) {
+  for (const auto& it : last_active_profiles) {
+    if (it.GetString() == profile) {
+      return true;
+    }
+  }
+  return false;
+}
+
+bool CanImportPasswordsForType(user_data_importer::ImporterType type) {
+  return false;
+}
+
+}  // namespace
+
+base::Value::List GetChromeSourceProfiles(
+    const base::FilePath& local_state_path) {
+  base::Value::List profiles;
+  if (base::PathExists(local_state_path)) {
+    std::string local_state_content;
+    base::ReadFileToString(local_state_path, &local_state_content);
+    std::optional<base::Value::Dict> local_state_dict =
+        base::JSONReader::ReadDict(local_state_content,
+                                   base::JSON_PARSE_CHROMIUM_EXTENSIONS);
+    if (!local_state_dict)
+      return profiles;
+
+    const auto* profile_dict = local_state_dict->FindDict("profile");
+    if (profile_dict) {
+      const auto* last_active_profiles =
+          profile_dict->FindList("last_active_profiles");
+
+      const auto* info_cache = profile_dict->FindDict("info_cache");
+      if (info_cache) {
+        for (const auto value : *info_cache) {
+          const auto* profile = value.second.GetIfDict();
+          if (!profile)
+            continue;
+
+          auto* name = profile->FindString("name");
+          if (!name) {
+            continue;
+          }
+          base::Value::Dict entry;
+          entry.Set("id", value.first);
+          entry.Set("name", *name);
+          if (last_active_profiles)
+            entry.Set("last_active",
+                      IsLastActiveProfile(value.first, *last_active_profiles));
+
+          auto* avatar_icon = profile->FindString("avatar_icon");
+          if (avatar_icon) {
+            entry.Set("avatar_icon", *avatar_icon);
+          }
+          auto active_time = profile->FindDouble("active_time");
+          if (active_time) {
+            entry.Set("active_time", *active_time);
+          }
+          profiles.Append(std::move(entry));
+        }
+      }
+    }
+  }
+  if (profiles.empty()) {
+    base::Value::Dict entry;
+    entry.Set("id", "");
+    entry.Set("name", "Default");
+    profiles.Append(std::move(entry));
+  }
+  return profiles;
+}
+
+bool ChromeImporterCanImport(const base::FilePath& profile,
+                             user_data_importer::ImporterType type,
+                             uint16_t* services_supported) {
+  DCHECK(services_supported);
+  *services_supported = user_data_importer::NONE;
+
+  base::FilePath bookmarks = profile.Append(
+      base::FilePath::StringType(FILE_PATH_LITERAL("Bookmarks")));
+  if (base::PathExists(bookmarks)) {
+    *services_supported |= user_data_importer::FAVORITES;
+  }
+
+  base::FilePath history =
+      profile.Append(base::FilePath::StringType(FILE_PATH_LITERAL("History")));
+  if (base::PathExists(history)) {
+    *services_supported |= user_data_importer::HISTORY;
+  }
+
+  if (CanImportPasswordsForType(type)) {
+    base::FilePath passwords = profile.Append(
+        base::FilePath::StringType(FILE_PATH_LITERAL("Login Data")));
+    base::FilePath passwords_for_account =
+        profile.Append(base::FilePath::StringType(
+            FILE_PATH_LITERAL("Login Data For Account")));
+    if (base::PathExists(passwords) ||
+        base::PathExists(passwords_for_account)) {
+      *services_supported |= user_data_importer::PASSWORDS;
+    }
+  }
+
+#if BUILDFLAG(ENABLE_EXTENSIONS)
+  if (HasImportableExtensions(profile))
+    *services_supported |= user_data_importer::EXTENSIONS;
+#endif
+
+  return *services_supported != user_data_importer::NONE;
+}
+
+#if BUILDFLAG(ENABLE_EXTENSIONS)
+std::optional<std::vector<std::string>> GetImportableChromeExtensionsList(
+    const base::FilePath& profile_path) {
+  if (auto extensions = GetChromeExtensionsList(profile_path)) {
+    return GetImportableListFromChromeExtensionsList(extensions.value());
+  }
+  return std::nullopt;
+}
+#endif
--- /dev/null
+++ b/chrome/common/importer/chrome_importer_utils.h
@@ -0,0 +1,66 @@
+/* Copyright (c) 2019 The Brave Authors, 2025 imput. All rights reserved.
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this file,
+ * You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef BRAVE_COMMON_IMPORTER_CHROME_IMPORTER_UTILS_H_
+#define BRAVE_COMMON_IMPORTER_CHROME_IMPORTER_UTILS_H_
+
+#include <optional>
+#include <string>
+#include <vector>
+
+#include "base/values.h"
+#include "build/build_config.h"
+#include "components/user_data_importer/common/importer_type.h"
+#include "extensions/buildflags/buildflags.h"
+
+namespace base {
+class FilePath;
+}  // namespace base
+
+// Chrome / Chromium paths
+// https://chromium.googlesource.com/chromium/src/+/HEAD/docs/user_data_dir.md
+base::FilePath GetChromeUserDataFolder();
+base::FilePath GetChromeBetaUserDataFolder();
+base::FilePath GetChromeDevUserDataFolder();
+#if !BUILDFLAG(IS_LINUX)
+// Canary is not available on Linux
+base::FilePath GetCanaryUserDataFolder();
+#endif
+
+#if BUILDFLAG(IS_WIN) || BUILDFLAG(IS_MAC)
+// Arc only has Windows/Mac builds
+base::FilePath GetArcUserDataFolder();
+base::FilePath GetCometUserDataFolder();
+#endif
+
+#if BUILDFLAG(IS_MAC)
+// Dia only has Windows/Mac builds
+base::FilePath GetDiaUserDataFolder();
+#endif
+
+base::FilePath GetChromiumUserDataFolder();
+
+base::FilePath GetEdgeUserDataFolder();
+
+base::FilePath GetVivaldiUserDataFolder();
+base::FilePath GetOperaUserDataFolder();
+base::FilePath GetYandexUserDataFolder();
+base::FilePath GetWhaleUserDataFolder();
+base::FilePath GetBraveUserDataFolder();
+
+#if BUILDFLAG(IS_LINUX)
+base::FilePath GetOperaSnapUserDataFolder();
+#endif
+base::Value::List GetChromeSourceProfiles(const base::FilePath& local_state);
+bool ChromeImporterCanImport(const base::FilePath& profile,
+                             user_data_importer::ImporterType type,
+                             uint16_t* services_supported);
+
+#if BUILDFLAG(ENABLE_EXTENSIONS)
+std::optional<std::vector<std::string>> GetImportableChromeExtensionsList(
+    const base::FilePath& profile_path);
+#endif
+
+#endif  // BRAVE_COMMON_IMPORTER_CHROME_IMPORTER_UTILS_H_
--- /dev/null
+++ b/chrome/common/importer/importer_constants.h
@@ -0,0 +1,38 @@
+/* Copyright (c) 2020 The Brave Authors. All rights reserved.
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this file,
+ * You can obtain one at https://mozilla.org/MPL/2.0/. */
+
+#ifndef BRAVE_COMMON_IMPORTER_IMPORTER_CONSTANTS_H_
+#define BRAVE_COMMON_IMPORTER_IMPORTER_CONSTANTS_H_
+
+#include "build/build_config.h"
+
+// Prefs files that holds installed extension list.
+inline constexpr char kChromeSecurePreferencesFile[] = "Secure Preferences";
+inline constexpr char kChromePreferencesFile[] = "Preferences";
+
+inline constexpr char kChromeExtensionsListPath[] = "extensions.settings";
+inline constexpr char kChromeLocalStateFile[] = "Local State";
+
+// Browser names section, the names mostly match the identifier that is used to
+// identify the default browser, if you change these constants(or adding a new
+// one) make sure that brave://welcome page will identify this browser as the
+// default one
+inline constexpr char kGoogleChromeBrowser[] = "Google Chrome";
+inline constexpr char kGoogleChromeBrowserBeta[] = "Google Chrome Beta";
+inline constexpr char kGoogleChromeBrowserDev[] = "Google Chrome Dev";
+inline constexpr char kGoogleChromeBrowserCanary[] = "Google Chrome Canary";
+inline constexpr char kChromiumBrowser[] = "Chromium";
+inline constexpr char kMicrosoftEdgeBrowser[] = "Microsoft Edge";
+inline constexpr char kVivaldiBrowser[] = "Vivaldi";
+inline constexpr char kOperaBrowser[] = "Opera";
+inline constexpr char kYandexBrowser[] = "Yandex";
+inline constexpr char kWhaleBrowser[] = "NAVER Whale";
+inline constexpr char kArcBrowser[] = "Arc";
+inline constexpr char kDiaBrowser[] = "Dia";
+inline constexpr char kPerplexityCometBrowser[] = "Perplexity Comet";
+inline constexpr char kBraveBrowser[] = "Brave";
+// End of browser names section
+
+#endif  // BRAVE_COMMON_IMPORTER_IMPORTER_CONSTANTS_H_
--- /dev/null
+++ b/chrome/common/importer/scoped_copy_file.cc
@@ -0,0 +1,20 @@
+/* Copyright 2020 The Brave Authors, 2025 imput. All rights reserved.
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this file,
+ * You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "chrome/common/importer/scoped_copy_file.h"
+
+#include "base/files/file_path.h"
+#include "base/files/file_util.h"
+
+ScopedCopyFile::ScopedCopyFile(const base::FilePath& original_file_path) {
+  DCHECK(base::PathExists(original_file_path));
+  if (base::CreateTemporaryFile(&copied_file_path_))
+    copy_success_ = base::CopyFile(original_file_path, copied_file_path_);
+}
+
+ScopedCopyFile::~ScopedCopyFile() {
+  if (base::PathExists(copied_file_path_))
+    base::DeleteFile(copied_file_path_);
+}
--- /dev/null
+++ b/chrome/common/importer/scoped_copy_file.h
@@ -0,0 +1,27 @@
+/* Copyright 2020 The Brave Authors. All rights reserved.
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this file,
+ * You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef BRAVE_COMMON_IMPORTER_SCOPED_COPY_FILE_H_
+#define BRAVE_COMMON_IMPORTER_SCOPED_COPY_FILE_H_
+
+#include "base/files/file_path.h"
+
+class ScopedCopyFile {
+ public:
+  explicit ScopedCopyFile(const base::FilePath& original_file_path);
+  ~ScopedCopyFile();
+
+  ScopedCopyFile(const ScopedCopyFile&) = delete;
+  ScopedCopyFile& operator=(const ScopedCopyFile&) = delete;
+
+  bool copy_success() const { return copy_success_; }
+  base::FilePath copied_file_path() const { return copied_file_path_; }
+
+ private:
+  bool copy_success_ = false;
+  base::FilePath copied_file_path_;
+};
+
+#endif  // BRAVE_COMMON_IMPORTER_SCOPED_COPY_FILE_H_
--- /dev/null
+++ b/chrome/common/importer/chrome_importer_utils_linux.cc
@@ -0,0 +1,133 @@
+/* Copyright (c) 2018 The Brave Authors, 2025 imput. All rights reserved.
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this file,
+ * You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "chrome/common/importer/chrome_importer_utils.h"
+
+#include "base/base_paths.h"
+#include "base/files/file_path.h"
+#include "base/files/file_util.h"
+#include "base/path_service.h"
+
+base::FilePath GetChromeUserDataFolder() {
+  base::FilePath result;
+  if (!base::PathService::Get(base::DIR_HOME, &result))
+    return base::FilePath();
+
+  result = result.Append(".config");
+  result = result.Append("google-chrome");
+
+  return result;
+}
+
+base::FilePath GetChromeBetaUserDataFolder() {
+  base::FilePath result;
+  if (!base::PathService::Get(base::DIR_HOME, &result))
+    return base::FilePath();
+
+  result = result.Append(".config");
+  result = result.Append("google-chrome-beta");
+
+  return result;
+}
+
+base::FilePath GetChromeDevUserDataFolder() {
+  base::FilePath result;
+  if (!base::PathService::Get(base::DIR_HOME, &result))
+    return base::FilePath();
+
+  result = result.Append(".config");
+  result = result.Append("google-chrome-unstable");
+
+  return result;
+}
+
+base::FilePath GetVivaldiUserDataFolder() {
+  base::FilePath result;
+  if (!base::PathService::Get(base::DIR_HOME, &result))
+    return base::FilePath();
+
+  return result.Append(".config").Append("vivaldi");
+}
+
+base::FilePath GetChromiumUserDataFolder() {
+  base::FilePath result;
+  if (!base::PathService::Get(base::DIR_HOME, &result))
+    return base::FilePath();
+
+  result = result.Append(".config");
+  result = result.Append("chromium");
+
+  return result;
+}
+
+base::FilePath GetEdgeUserDataFolder() {
+  base::FilePath result;
+  if (!base::PathService::Get(base::DIR_HOME, &result))
+    return base::FilePath();
+
+  result = result.Append(".config");
+  result = result.Append("microsoft-edge");
+
+  return result;
+}
+
+base::FilePath GetOperaUserDataFolder() {
+  base::FilePath result;
+  if (!base::PathService::Get(base::DIR_HOME, &result))
+    return base::FilePath();
+
+  result = result.Append(".config");
+  result = result.Append("opera");
+
+  return result;
+}
+
+base::FilePath GetOperaSnapUserDataFolder() {
+  base::FilePath result;
+  if (!base::PathService::Get(base::DIR_HOME, &result))
+    return base::FilePath();
+
+  result = result.Append("snap");
+  result = result.Append("opera");
+  result = result.Append("current");
+  result = result.Append(".config");
+  result = result.Append("opera");
+
+  return result;
+}
+
+base::FilePath GetYandexUserDataFolder() {
+  base::FilePath result;
+  if (!base::PathService::Get(base::DIR_HOME, &result))
+    return base::FilePath();
+
+  result = result.Append(".config");
+  result = result.Append("yandex-browser");
+
+  return result;
+}
+
+base::FilePath GetWhaleUserDataFolder() {
+  base::FilePath result;
+  if (!base::PathService::Get(base::DIR_HOME, &result))
+    return base::FilePath();
+
+  result = result.Append(".config");
+  result = result.Append("naver-whale");
+
+  return result;
+}
+
+base::FilePath GetBraveUserDataFolder() {
+  base::FilePath result;
+  if (!base::PathService::Get(base::DIR_HOME, &result))
+    return base::FilePath();
+
+  result = result.Append(".config");
+  result = result.Append("BraveSoftware");
+  result = result.Append("Brave-Browser");
+
+  return result;
+}
--- /dev/null
+++ b/chrome/common/importer/chrome_importer_utils_mac.mm
@@ -0,0 +1,82 @@
+/* Copyright (c) 2018 The Brave Authors, 2025 imput. All rights reserved.
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this file,
+ * You can obtain one at https://mozilla.org/MPL/2.0/. */
+
+#include <Cocoa/Cocoa.h>
+#include <sys/param.h>
+
+#include "chrome/common/importer/chrome_importer_utils.h"
+
+#include "base/apple/foundation_util.h"
+#include "base/files/file_util.h"
+
+base::FilePath GetChromeUserDataFolder() {
+  base::FilePath result = base::apple::GetUserLibraryPath();
+  return result.Append("Application Support/Google/Chrome");
+}
+
+base::FilePath GetChromeBetaUserDataFolder() {
+  base::FilePath result = base::apple::GetUserLibraryPath();
+  return result.Append("Application Support/Google/Chrome Beta");
+}
+
+base::FilePath GetChromeDevUserDataFolder() {
+  base::FilePath result = base::apple::GetUserLibraryPath();
+  return result.Append("Application Support/Google/Chrome Dev");
+}
+
+base::FilePath GetCanaryUserDataFolder() {
+  base::FilePath result = base::apple::GetUserLibraryPath();
+  return result.Append("Application Support/Google/Chrome Canary");
+}
+
+base::FilePath GetVivaldiUserDataFolder() {
+  base::FilePath result = base::apple::GetUserLibraryPath();
+  return result.Append("Application Support/Vivaldi");
+}
+
+base::FilePath GetChromiumUserDataFolder() {
+  base::FilePath result = base::apple::GetUserLibraryPath();
+  return result.Append("Application Support/Chromium");
+}
+
+base::FilePath GetEdgeUserDataFolder() {
+  base::FilePath result = base::apple::GetUserLibraryPath();
+  return result.Append("Application Support/Microsoft Edge");
+}
+
+base::FilePath GetOperaUserDataFolder() {
+  base::FilePath result = base::apple::GetUserLibraryPath();
+  return result.Append("Application Support/com.operasoftware.Opera");
+}
+
+base::FilePath GetYandexUserDataFolder() {
+  base::FilePath result = base::apple::GetUserLibraryPath();
+  return result.Append("Application Support/Yandex/YandexBrowser");
+}
+
+base::FilePath GetWhaleUserDataFolder() {
+  base::FilePath result = base::apple::GetUserLibraryPath();
+  return result.Append("Application Support").Append("Naver").Append("Whale");
+}
+
+base::FilePath GetArcUserDataFolder() {
+  base::FilePath result = base::apple::GetUserLibraryPath();
+  return result.Append("Application Support").Append("Arc").Append("User Data");
+}
+
+base::FilePath GetDiaUserDataFolder() {
+  base::FilePath result = base::apple::GetUserLibraryPath();
+  return result.Append("Application Support").Append("Dia").Append("User Data");
+}
+
+base::FilePath GetCometUserDataFolder() {
+  base::FilePath result = base::apple::GetUserLibraryPath();
+  return result.Append("Application Support").Append("Comet");
+}
+
+base::FilePath GetBraveUserDataFolder() {
+  base::FilePath result = base::apple::GetUserLibraryPath();
+  return result.Append("Application Support").Append("BraveSoftware").Append("Brave-Browser");
+}
--- /dev/null
+++ b/chrome/common/importer/chrome_importer_utils_win.cc
@@ -0,0 +1,155 @@
+/* Copyright (c) 2021 The Brave Authors, 2025 imput. All rights reserved.
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this file,
+ * You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "chrome/common/importer/chrome_importer_utils.h"
+
+#include "base/files/file_util.h"
+#include "base/path_service.h"
+
+base::FilePath GetChromeUserDataFolder() {
+  base::FilePath result;
+  if (!base::PathService::Get(base::DIR_LOCAL_APP_DATA, &result))
+    return base::FilePath();
+
+  result = result.AppendASCII("Google");
+  result = result.AppendASCII("Chrome");
+  result = result.AppendASCII("User Data");
+
+  return result;
+}
+
+base::FilePath GetChromeBetaUserDataFolder() {
+  base::FilePath result;
+  if (!base::PathService::Get(base::DIR_LOCAL_APP_DATA, &result))
+    return base::FilePath();
+
+  result = result.AppendASCII("Google");
+  result = result.AppendASCII("Chrome Beta");
+  result = result.AppendASCII("User Data");
+
+  return result;
+}
+
+base::FilePath GetChromeDevUserDataFolder() {
+  base::FilePath result;
+  if (!base::PathService::Get(base::DIR_LOCAL_APP_DATA, &result))
+    return base::FilePath();
+
+  result = result.AppendASCII("Google");
+  result = result.AppendASCII("Chrome Dev");
+  result = result.AppendASCII("User Data");
+
+  return result;
+}
+
+base::FilePath GetCanaryUserDataFolder() {
+  base::FilePath result;
+  if (!base::PathService::Get(base::DIR_LOCAL_APP_DATA, &result))
+    return base::FilePath();
+
+  result = result.AppendASCII("Google");
+  result = result.AppendASCII("Chrome SxS");
+  result = result.AppendASCII("User Data");
+
+  return result;
+}
+
+base::FilePath GetVivaldiUserDataFolder() {
+  base::FilePath result;
+  if (!base::PathService::Get(base::DIR_LOCAL_APP_DATA, &result))
+    return base::FilePath();
+
+  result = result.AppendASCII("Vivaldi");
+  result = result.AppendASCII("User Data");
+
+  return result;
+}
+
+base::FilePath GetChromiumUserDataFolder() {
+  base::FilePath result;
+  if (!base::PathService::Get(base::DIR_LOCAL_APP_DATA, &result))
+    return base::FilePath();
+
+  result = result.AppendASCII("Chromium");
+  result = result.AppendASCII("User Data");
+
+  return result;
+}
+
+base::FilePath GetEdgeUserDataFolder() {
+  base::FilePath result;
+  if (!base::PathService::Get(base::DIR_LOCAL_APP_DATA, &result))
+    return base::FilePath();
+
+  result = result.AppendASCII("Microsoft");
+  result = result.AppendASCII("Edge");
+  result = result.AppendASCII("User Data");
+  return result;
+}
+
+base::FilePath GetOperaUserDataFolder() {
+  base::FilePath result;
+  if (!base::PathService::Get(base::DIR_ROAMING_APP_DATA, &result))
+    return base::FilePath();
+
+  result = result.AppendASCII("Opera Software");
+  result = result.AppendASCII("Opera Stable");
+
+  return result;
+}
+
+base::FilePath GetYandexUserDataFolder() {
+  base::FilePath result;
+  if (!base::PathService::Get(base::DIR_LOCAL_APP_DATA, &result))
+    return base::FilePath();
+
+  result = result.AppendASCII("Yandex");
+  result = result.AppendASCII("YandexBrowser");
+  result = result.AppendASCII("User Data");
+
+  return result;
+}
+
+base::FilePath GetWhaleUserDataFolder() {
+  base::FilePath result;
+  if (!base::PathService::Get(base::DIR_LOCAL_APP_DATA, &result))
+    return base::FilePath();
+
+  return result.AppendASCII("Naver")
+      .AppendASCII("Naver Whale")
+      .AppendASCII("User Data");
+}
+
+base::FilePath GetArcUserDataFolder() {
+  base::FilePath result;
+  if (!base::PathService::Get(base::DIR_LOCAL_APP_DATA, &result))
+    return base::FilePath();
+
+  return result.AppendASCII("Packages")
+      .AppendASCII("TheBrowserCompany.Arc_ttt1ap7aakyb4")
+      .AppendASCII("LocalCache")
+      .AppendASCII("Local")
+      .AppendASCII("User Data");
+}
+
+base::FilePath GetCometUserDataFolder() {
+  base::FilePath result;
+  if (!base::PathService::Get(base::DIR_LOCAL_APP_DATA, &result))
+    return base::FilePath();
+
+  return result.AppendASCII("Perplexity")
+      .AppendASCII("Comet")
+      .AppendASCII("User Data");
+}
+
+base::FilePath GetBraveUserDataFolder() {
+  base::FilePath result;
+  if (!base::PathService::Get(base::DIR_LOCAL_APP_DATA, &result))
+    return base::FilePath();
+
+  return result.AppendASCII("BraveSoftware")
+      .AppendASCII("Brave-Browser")
+      .AppendASCII("User Data");
+}
--- /dev/null
+++ b/chrome/browser/ui/webui/settings/brave_import_data_handler.cc
@@ -0,0 +1,219 @@
+/* Copyright (c) 2020 The Brave Authors. All rights reserved.
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this file,
+ * You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "chrome/browser/ui/webui/settings/brave_import_data_handler.h"
+
+#include <memory>
+#include <string>
+#include <utility>
+
+#include "base/check.h"
+#include "base/logging.h"
+#include "chrome/browser/importer/brave_external_process_importer_host.h"
+#include "chrome/browser/importer/importer_list.h"
+#include "chrome/browser/importer/profile_writer.h"
+#include "chrome/browser/profiles/profile.h"
+#include "content/public/browser/browser_task_traits.h"
+#include "content/public/browser/browser_thread.h"
+#include "content/public/browser/web_contents.h"
+
+#if BUILDFLAG(IS_MAC)
+#include "base/apple/foundation_util.h"
+#include "base/files/file_path.h"
+#include "base/files/file_util.h"
+#include "base/task/thread_pool.h"
+#include "chrome/browser/ui/webui/settings/brave_full_disk_access_confirm_dialog_delegate.h"
+#include "chrome/browser/ui/browser_finder.h"
+#include "chrome/browser/ui/tab_modal_confirm_dialog.h"
+#endif  // BUILDFLAG(IS_MAC)
+
+namespace {
+#if BUILDFLAG(IS_MAC)
+bool HasProperDiskAccessPermission(uint16_t imported_items) {
+  DCHECK(imported_items);
+
+  const base::FilePath& library_dir = base::apple::GetUserLibraryPath();
+  const base::FilePath safari_dir = library_dir.Append("Safari");
+
+  if (imported_items & user_data_importer::FAVORITES) {
+    const base::FilePath bookmarks_path = safari_dir.Append("Bookmarks.plist");
+    if (!PathIsWritable(bookmarks_path)) {
+      LOG(ERROR) << __func__ << " " << bookmarks_path << " is not accessible."
+                 << " Please check full disk access permission.";
+      return false;
+    }
+  }
+
+  if (imported_items & user_data_importer::HISTORY) {
+    const base::FilePath history_path = safari_dir.Append("History.plist");
+    if (!PathIsWritable(history_path)) {
+      LOG(ERROR) << __func__ << " " << history_path << " is not accessible."
+                 << " Please check full disk access permission.";
+      return false;
+    }
+  }
+
+  return true;
+}
+#endif  // BUILDFLAG(IS_MAC)
+constexpr char kImportStatusSucceeded[] = "succeeded";
+constexpr char kImportStatusFailed[] = "failed";
+}  // namespace
+
+namespace settings {
+
+BraveImportDataHandler::BraveImportDataHandler() = default;
+BraveImportDataHandler::~BraveImportDataHandler() = default;
+
+void BraveImportDataHandler::StartImport(
+    const user_data_importer::SourceProfile& source_profile,
+    uint16_t imported_items) {
+  if (!imported_items) {
+    return;
+  }
+  Profile* profile = Profile::FromWebUI(web_ui());
+#if BUILDFLAG(IS_MAC)
+  CheckDiskAccess(imported_items, source_profile.source_path,
+                  source_profile.importer_type,
+                  base::BindOnce(&BraveImportDataHandler::StartImportImpl,
+                                 weak_factory_.GetWeakPtr(), source_profile,
+                                 imported_items, profile));
+#else
+  StartImportImpl(source_profile, imported_items, profile);
+#endif
+}
+
+void BraveImportDataHandler::StartImportImpl(
+    const user_data_importer::SourceProfile& source_profile,
+    uint16_t imported_items,
+    Profile* profile) {
+  // If another import is already ongoing, let it finish silently.
+  if (import_observers_.count(source_profile.source_path)) {
+    import_observers_.erase(source_profile.source_path);
+  }
+
+  FireWebUIListener("import-data-status-changed", base::Value("inProgress"));
+
+  // Using weak pointers because it destroys itself when finshed.
+  auto* importer_host = new BraveExternalProcessImporterHost();
+  import_observers_[source_profile.source_path] =
+      std::make_unique<BraveImporterObserver>(
+          importer_host, source_profile, imported_items,
+          base::BindRepeating(&BraveImportDataHandler::NotifyImportProgress,
+                              weak_factory_.GetWeakPtr()));
+
+  importer_host->set_parent_window(
+      web_ui()->GetWebContents()->GetTopLevelNativeWindow());
+  importer_host->set_parent_view(web_ui()->GetWebContents()->GetNativeView());
+
+  importer_host->StartImportSettings(source_profile, profile, imported_items,
+                                     new ProfileWriter(profile));
+}
+
+void BraveImportDataHandler::NotifyImportProgress(
+    const user_data_importer::SourceProfile& source_profile,
+    const base::Value::Dict& info) {
+  const std::string* event = info.FindString("event");
+  if (!event) {
+    return;
+  }
+  if (*event == "ImportItemEnded") {
+    import_did_succeed_ = true;
+  } else if (*event == "ImportEnded") {
+    content::GetUIThreadTaskRunner({})->PostTask(
+        FROM_HERE, base::BindOnce(&BraveImportDataHandler::OnImportEnded,
+                                  weak_factory_.GetWeakPtr(), source_profile));
+  }
+}
+
+void BraveImportDataHandler::HandleImportData(const base::Value::List& args) {
+  ImportDataHandler::HandleImportData(args);
+}
+
+void BraveImportDataHandler::OnImportEnded(
+    const user_data_importer::SourceProfile& source_profile) {
+  import_observers_.erase(source_profile.source_path);
+  FireWebUIListener("import-data-status-changed",
+                    base::Value(import_did_succeed_ ? kImportStatusSucceeded
+                                                    : kImportStatusFailed));
+}
+
+void BraveImportDataHandler::OnJavascriptDisallowed() {
+  ImportDataHandler::OnJavascriptDisallowed();
+
+  // When the WebUI is unloading, we ignore all further updates from the host as
+  // ImportDataHandler does.
+  import_observers_.clear();
+}
+
+const user_data_importer::SourceProfile&
+BraveImportDataHandler::GetSourceProfileAt(int browser_index) {
+  return importer_list_->GetSourceProfileAt(browser_index);
+}
+
+#if BUILDFLAG(IS_MAC)
+void BraveImportDataHandler::CheckDiskAccess(
+    uint16_t imported_items,
+    base::FilePath source_path,
+    user_data_importer::ImporterType importer_type,
+    ContinueImportCallback callback) {
+  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
+
+  guide_dialog_is_requested_ = false;
+
+  if (importer_type == user_data_importer::TYPE_SAFARI) {
+    // Start import if Brave has full disk access permission.
+    // If not, show dialog that has infos about that permission.
+    base::ThreadPool::PostTaskAndReplyWithResult(
+        FROM_HERE, {base::MayBlock()},
+        base::BindOnce(&HasProperDiskAccessPermission, imported_items),
+        base::BindOnce(&BraveImportDataHandler::OnGetDiskAccessPermission,
+                       weak_factory_.GetWeakPtr(), std::move(callback),
+                       source_path));
+    return;
+  }
+  std::move(callback).Run();
+}
+
+void BraveImportDataHandler::OnGetDiskAccessPermission(
+    ContinueImportCallback callback,
+    base::FilePath source_path,
+    bool allowed) {
+  if (!allowed) {
+    // Notify to webui to finish import process and launch tab modal dialog
+    // to guide full disk access information to users.
+    // Guide dialog will be opened after import dialog is closed.
+    FireWebUIListener("import-data-status-changed", base::Value("failed"));
+    if (import_observers_.count(source_path)) {
+      import_observers_[source_path]->ImportEnded();
+    }
+    // Observing web_contents is started here to know the closing timing of
+    // import dialog.
+    Observe(web_ui()->GetWebContents());
+
+    guide_dialog_is_requested_ = true;
+    return;
+  }
+
+  std::move(callback).Run();
+}
+
+void BraveImportDataHandler::DidStopLoading() {
+  Observe(nullptr);
+
+  if (!guide_dialog_is_requested_) {
+    return;
+  }
+
+  guide_dialog_is_requested_ = false;
+
+  auto* web_contents = web_ui()->GetWebContents();
+  TabModalConfirmDialog::Create(
+      std::make_unique<FullDiskAccessConfirmDialogDelegate>(
+          web_contents, chrome::FindBrowserWithTab(web_contents)),
+      web_contents);
+}
+#endif
+}  // namespace settings
--- /dev/null
+++ b/chrome/browser/ui/webui/settings/brave_import_data_handler.h
@@ -0,0 +1,86 @@
+/* Copyright (c) 2020 The Brave Authors. All rights reserved.
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this file,
+ * You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef BRAVE_BROWSER_UI_WEBUI_SETTINGS_BRAVE_IMPORT_DATA_HANDLER_H_
+#define BRAVE_BROWSER_UI_WEBUI_SETTINGS_BRAVE_IMPORT_DATA_HANDLER_H_
+
+#include <memory>
+#include <unordered_map>
+
+#include "base/memory/weak_ptr.h"
+#include "chrome/browser/ui/webui/settings/brave_importer_observer.h"
+#include "build/build_config.h"
+#include "chrome/browser/ui/webui/settings/import_data_handler.h"
+#include "content/public/browser/web_contents_observer.h"
+
+namespace settings {
+
+// This class checks whether Brave has full disk access permission to import
+// safari data on macOS. ImportDataHandler::StartImport() will be run after
+// checking disk access permission. If Brave doesn't have that permission, this
+// will launch tab modal dialog to notify users about this lack of permission.
+
+// We should display tab modal dialog after import dialog is closed from webui.
+// To do that, this observes web contents to launch dialog after import dialog
+// closed. If dialog is launched right after notifying import failure,
+// dialog will be closed immediately because tab modal dialog is closed with
+// new navigation start and tab is newly loaded for closing webui import dialog.
+// The reason why native tab modal dialog is used here is to avoid modifying
+// upstream import html/js source code.
+class BraveImportDataHandler : public ImportDataHandler,
+                                      content::WebContentsObserver {
+ public:
+  BraveImportDataHandler();
+  ~BraveImportDataHandler() override;
+
+  BraveImportDataHandler(const BraveImportDataHandler&) = delete;
+  BraveImportDataHandler& operator=(const BraveImportDataHandler&) = delete;
+
+ protected:
+  using ContinueImportCallback = base::OnceCallback<void()>;
+
+  const user_data_importer::SourceProfile& GetSourceProfileAt(
+      int browser_index);
+  void HandleImportData(const base::Value::List& args);
+  // ImportDataHandler overrides:
+  void StartImport(const user_data_importer::SourceProfile& source_profile,
+                   uint16_t imported_items) override;
+
+  void StartImportImpl(const user_data_importer::SourceProfile& source_profile,
+                       uint16_t imported_items,
+                       Profile* profile);
+  virtual void NotifyImportProgress(
+      const user_data_importer::SourceProfile& source_profile,
+      const base::Value::Dict& info);
+  virtual void OnImportEnded(
+      const user_data_importer::SourceProfile& source_profile);
+
+  void OnJavascriptDisallowed() override;
+
+  void OnStartImport(const user_data_importer::SourceProfile& source_profile,
+                     uint16_t imported_items);
+#if BUILDFLAG(IS_MAC)
+  void CheckDiskAccess(uint16_t imported_items,
+                       base::FilePath source_path,
+                       user_data_importer::ImporterType importer_type,
+                       ContinueImportCallback callback);
+  void OnGetDiskAccessPermission(ContinueImportCallback callback,
+                                 base::FilePath source_path,
+                                 bool allowed);
+
+  // content::WebContentsObserver overrides:
+  void DidStopLoading() override;
+
+  bool guide_dialog_is_requested_ = false;
+#endif
+ private:
+  std::unordered_map<base::FilePath, std::unique_ptr<BraveImporterObserver>>
+      import_observers_;
+  base::WeakPtrFactory<BraveImportDataHandler> weak_factory_{this};
+};
+
+}  // namespace settings
+
+#endif  // BRAVE_BROWSER_UI_WEBUI_SETTINGS_BRAVE_IMPORT_DATA_HANDLER_H_
--- /dev/null
+++ b/chrome/browser/ui/webui/settings/brave_importer_observer.cc
@@ -0,0 +1,85 @@
+/* Copyright (c) 2022 The Brave Authors. All rights reserved.
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this file,
+ * You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "chrome/browser/ui/webui/settings/brave_importer_observer.h"
+
+#include <utility>
+
+#include "base/check.h"
+#include "chrome/browser/importer/external_process_importer_host.h"
+
+BraveImporterObserver::BraveImporterObserver(
+    ExternalProcessImporterHost* importer_host,
+    const user_data_importer::SourceProfile& source_profile,
+    uint16_t imported_items,
+    ReportProgressCallback callback)
+    : source_profile_(source_profile),
+      imported_items_(imported_items),
+      callback_(std::move(callback)),
+      importer_host_(importer_host) {
+  DCHECK(importer_host);
+  importer_host->set_observer(this);
+}
+
+BraveImporterObserver::~BraveImporterObserver() {
+  if (importer_host_)
+    importer_host_->set_observer(nullptr);
+}
+
+// user_data_importer::ImporterProgressObserver:
+void BraveImporterObserver::ImportStarted() {
+  if (import_started_called_)
+    return;
+  import_started_called_ = true;
+  base::Value::Dict data;
+  data.Set("importer_name", source_profile_.importer_name);
+  data.Set("importer_type", source_profile_.importer_type);
+  data.Set("items_to_import", imported_items_);
+  data.Set("event", "ImportStarted");
+  callback_.Run(source_profile_, data);
+}
+
+void BraveImporterObserver::ImportItemStarted(
+    user_data_importer::ImportItem item) {
+  base::Value::Dict data;
+  data.Set("importer_name", source_profile_.importer_name);
+  data.Set("importer_type", source_profile_.importer_type);
+  data.Set("items_to_import", imported_items_);
+  data.Set("event", "ImportItemStarted");
+  data.Set("item", item);
+  callback_.Run(source_profile_, data);
+}
+
+void BraveImporterObserver::ImportItemEnded(
+    user_data_importer::ImportItem item) {
+  base::Value::Dict data;
+  data.Set("importer_name", source_profile_.importer_name);
+  data.Set("importer_type", source_profile_.importer_type);
+  data.Set("items_to_import", imported_items_);
+  data.Set("event", "ImportItemEnded");
+  data.Set("item", item);
+  callback_.Run(source_profile_, data);
+}
+
+void BraveImporterObserver::ImportEnded() {
+  base::Value::Dict data;
+  data.Set("importer_name", source_profile_.importer_name);
+  data.Set("importer_type", source_profile_.importer_type);
+  data.Set("items_to_import", imported_items_);
+  data.Set("event", "ImportEnded");
+
+  DCHECK(importer_host_);
+  if (importer_host_)
+    importer_host_->set_observer(nullptr);
+
+  importer_host_ = nullptr;
+
+  callback_.Run(source_profile_, data);
+}
+
+ExternalProcessImporterHost*
+BraveImporterObserver::GetImporterHostForTesting() {
+  return importer_host_.get();
+}
--- /dev/null
+++ b/chrome/browser/ui/webui/settings/brave_importer_observer.h
@@ -0,0 +1,50 @@
+/* Copyright (c) 2022 The Brave Authors. All rights reserved.
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this file,
+ * You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef BRAVE_BROWSER_UI_WEBUI_SETTINGS_BRAVE_IMPORTER_OBSERVER_H_
+#define BRAVE_BROWSER_UI_WEBUI_SETTINGS_BRAVE_IMPORTER_OBSERVER_H_
+
+#include "base/functional/callback.h"
+#include "base/gtest_prod_util.h"
+#include "base/memory/raw_ptr.h"
+#include "base/values.h"
+#include "chrome/browser/importer/importer_progress_observer.h"
+
+class ExternalProcessImporterHost;
+
+class BraveImporterObserver : public importer::ImporterProgressObserver {
+ public:
+  using ReportProgressCallback = base::RepeatingCallback<void(
+      const user_data_importer::SourceProfile& source_profile,
+      const base::Value::Dict&)>;
+
+  BraveImporterObserver(ExternalProcessImporterHost* host,
+                        const user_data_importer::SourceProfile& source_profile,
+                        uint16_t imported_items,
+                        ReportProgressCallback callback);
+  ~BraveImporterObserver() override;
+
+  void ImportStarted() override;
+  void ImportItemStarted(user_data_importer::ImportItem item) override;
+  void ImportItemEnded(user_data_importer::ImportItem item) override;
+  void ImportEnded() override;
+
+ private:
+  FRIEND_TEST_ALL_PREFIXES(BraveImporterObserverUnitTest, ImportEvents);
+
+  ExternalProcessImporterHost* GetImporterHostForTesting();
+
+  user_data_importer::SourceProfile source_profile_;
+  uint16_t imported_items_ = 0;
+  ReportProgressCallback callback_;
+  // By some reasons ImportStarted event is called few times from different
+  // places, we expect only one call.
+  bool import_started_called_ = false;
+  // If non-null it means importing is in progress. ImporterHost takes care
+  // of deleting itself when import is complete.
+  raw_ptr<ExternalProcessImporterHost> importer_host_;  // weak
+};
+
+#endif  // BRAVE_BROWSER_UI_WEBUI_SETTINGS_BRAVE_IMPORTER_OBSERVER_H_
--- /dev/null
+++ b/chrome/browser/importer/brave_external_process_importer_client.cc
@@ -0,0 +1,114 @@
+/* Copyright (c) 2020 The Brave Authors. All rights reserved.
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this file,
+ * You can obtain one at https://mozilla.org/MPL/2.0/. */
+
+#include "chrome/browser/importer/brave_external_process_importer_client.h"
+
+#include <utility>
+
+#include "base/functional/bind.h"
+#include "chrome/browser/importer/brave_in_process_importer_bridge.h"
+#include "chrome/grit/generated_resources.h"
+#include "content/public/browser/service_process_host.h"
+
+namespace {
+bool ShouldUseBraveImporter(user_data_importer::ImporterType type) {
+  switch (type) {
+    case user_data_importer::TYPE_CHROME:
+    case user_data_importer::TYPE_EDGE_CHROMIUM:
+    case user_data_importer::TYPE_VIVALDI:
+    case user_data_importer::TYPE_OPERA:
+    case user_data_importer::TYPE_YANDEX:
+    case user_data_importer::TYPE_WHALE:
+    case user_data_importer::TYPE_ARC:
+    case user_data_importer::TYPE_DIA:
+    case user_data_importer::TYPE_PERPLEXITY_COMET:
+    case user_data_importer::TYPE_BRAVE:
+      return true;
+    default:
+      return false;
+  }
+}
+}  // namespace
+
+template <>
+inline sandbox::mojom::Sandbox
+content::GetServiceSandboxType<chrome::mojom::ChromeProfileImport>() {
+  return sandbox::mojom::Sandbox::kNoSandbox;
+}
+
+BraveExternalProcessImporterClient::BraveExternalProcessImporterClient(
+    base::WeakPtr<ExternalProcessImporterHost> importer_host,
+    const user_data_importer::SourceProfile& source_profile,
+    uint16_t items,
+    InProcessImporterBridge* bridge)
+    : ExternalProcessImporterClient(importer_host,
+                                    source_profile,
+                                    items,
+                                    bridge) {}
+
+BraveExternalProcessImporterClient::
+    ~BraveExternalProcessImporterClient() = default;
+
+void BraveExternalProcessImporterClient::Start() {
+  if (!ShouldUseBraveImporter(source_profile_.importer_type)) {
+    ExternalProcessImporterClient::Start();
+    return;
+  }
+
+  AddRef();  // balanced in Cleanup.
+
+  auto options = content::ServiceProcessHost::Options()
+                     .WithDisplayName(IDS_UTILITY_PROCESS_PROFILE_IMPORTER_NAME)
+                     .Pass();
+  content::ServiceProcessHost::Launch(
+      brave_profile_import_.BindNewPipeAndPassReceiver(), std::move(options));
+
+  brave_profile_import_.set_disconnect_handler(
+      base::BindOnce(&ExternalProcessImporterClient::OnProcessCrashed, this));
+
+  base::flat_map<uint32_t, std::string> localized_strings;
+  brave_profile_import_->StartImport(
+      source_profile_, items_, localized_strings,
+      receiver_.BindNewPipeAndPassRemote());
+}
+
+void BraveExternalProcessImporterClient::Cancel() {
+  if (!ShouldUseBraveImporter(source_profile_.importer_type)) {
+    ExternalProcessImporterClient::Cancel();
+    return;
+  }
+
+  if (cancelled_)
+    return;
+
+  cancelled_ = true;
+  brave_profile_import_->CancelImport();
+  CloseMojoHandles();
+  Release();
+}
+
+void BraveExternalProcessImporterClient::CloseMojoHandles() {
+  if (!ShouldUseBraveImporter(source_profile_.importer_type)) {
+    ExternalProcessImporterClient::CloseMojoHandles();
+    return;
+  }
+
+  brave_profile_import_.reset();
+  receiver_.reset();
+}
+
+void BraveExternalProcessImporterClient::OnImportItemFinished(
+    user_data_importer::ImportItem import_item) {
+  if (!ShouldUseBraveImporter(source_profile_.importer_type)) {
+    ExternalProcessImporterClient::OnImportItemFinished(import_item);
+    return;
+  }
+
+  if (cancelled_)
+    return;
+
+  bridge_->NotifyItemEnded(import_item);
+  brave_profile_import_->ReportImportItemFinished(import_item);
+}
--- /dev/null
+++ b/chrome/browser/importer/brave_external_process_importer_client.h
@@ -0,0 +1,47 @@
+/* Copyright (c) 2020 The Brave Authors. All rights reserved.
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this file,
+ * You can obtain one at https://mozilla.org/MPL/2.0/. */
+
+#ifndef BRAVE_BROWSER_IMPORTER_BRAVE_EXTERNAL_PROCESS_IMPORTER_CLIENT_H_
+#define BRAVE_BROWSER_IMPORTER_BRAVE_EXTERNAL_PROCESS_IMPORTER_CLIENT_H_
+
+#include <string>
+
+#include "base/memory/weak_ptr.h"
+#include "chrome/common/importer/chrome_profile_import.mojom.h"
+#include "chrome/browser/importer/external_process_importer_client.h"
+#include "mojo/public/cpp/bindings/receiver.h"
+#include "mojo/public/cpp/bindings/remote.h"
+
+class BraveExternalProcessImporterClient
+    : public ExternalProcessImporterClient {
+ public:
+  BraveExternalProcessImporterClient(
+      base::WeakPtr<ExternalProcessImporterHost> importer_host,
+      const user_data_importer::SourceProfile& source_profile,
+      uint16_t items,
+      InProcessImporterBridge* bridge);
+
+  BraveExternalProcessImporterClient(
+      const BraveExternalProcessImporterClient&) = delete;
+  BraveExternalProcessImporterClient& operator=(
+      const BraveExternalProcessImporterClient&) = delete;
+
+  // ExternalProcessImportClient overrides:
+  void Start() override;
+  void Cancel() override;
+  void CloseMojoHandles() override;
+  void OnImportItemFinished(
+      user_data_importer::ImportItem import_item) override;
+
+ protected:
+  ~BraveExternalProcessImporterClient() override;
+
+ private:
+  // Used to start and stop the actual brave importer running in a different
+  // process.
+  mojo::Remote<chrome::mojom::ChromeProfileImport> brave_profile_import_;
+};
+
+#endif  // BRAVE_BROWSER_IMPORTER_BRAVE_EXTERNAL_PROCESS_IMPORTER_CLIENT_H_
--- /dev/null
+++ b/chrome/browser/importer/brave_external_process_importer_host.cc
@@ -0,0 +1,126 @@
+/* Copyright (c) 2019 The Brave Authors. All rights reserved.
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this file,
+ * You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "chrome/browser/importer/brave_external_process_importer_host.h"
+
+#include "base/check.h"
+#include "chrome/browser/importer/extensions_import_helpers.h"
+#include "chrome/browser/importer/importer_lock_dialog.h"
+#include "chrome/grit/generated_resources.h"
+
+BraveExternalProcessImporterHost::BraveExternalProcessImporterHost()
+    : weak_ptr_factory_(this) {}
+BraveExternalProcessImporterHost::~BraveExternalProcessImporterHost() = default;
+
+void BraveExternalProcessImporterHost::NotifyImportEnded() {
+  // If user chooses extension importing, start importing extensions.
+  // and NotifyImportEnded() will be called from OnGetChromeExtensionsList().
+  // Handling extensions importing after finishing all other properties makes
+  // logic simpler.
+  // Don't import if cancelled.
+#if BUILDFLAG(ENABLE_EXTENSIONS)
+  if (NeedToImportExtensions() && extensions_importer_) {
+    NotifyImportItemStarted(user_data_importer::EXTENSIONS);
+    if (extensions_importer_->Import(base::BindRepeating(
+            &BraveExternalProcessImporterHost::OnExtensionImported,
+            weak_ptr_factory_.GetWeakPtr()))) {
+      return;
+    }
+  }
+#endif
+  // Force tests to fail if |this| is deleted.
+  DCHECK(weak_ptr_factory_.GetWeakPtr());
+
+  // Otherwise, notifying here and importing is finished.
+  ExternalProcessImporterHost::NotifyImportEnded();
+}
+
+void BraveExternalProcessImporterHost::LaunchImportIfReady() {
+#if BUILDFLAG(ENABLE_EXTENSIONS)
+  if (NeedToImportExtensions()) {
+    if (!extensions_importer_) {
+      extensions_importer_ =
+          std::make_unique<extensions_import::ExtensionsImporter>(
+              source_profile_.source_path, profile_);
+      extensions_importer_->Prepare(base::BindOnce(
+          &BraveExternalProcessImporterHost::OnExtensionsImportReady,
+          weak_ptr_factory_.GetWeakPtr()));
+      return;
+    }
+    if (!extensions_import_ready_) {
+      return;
+    }
+  }
+#endif
+
+  if (!do_not_launch_import_for_testing_) {
+    CHECK(!client_);
+    ExternalProcessImporterHost::LaunchImportIfReady();
+  } else {
+    NotifyImportEnded();
+  }
+}
+
+void BraveExternalProcessImporterHost::DoNotLaunchImportForTesting() {
+  do_not_launch_import_for_testing_ = true;
+}
+
+void BraveExternalProcessImporterHost::NotifyImportEndedForTesting() {
+  ExternalProcessImporterHost::NotifyImportEnded();
+}
+
+importer::ImporterProgressObserver*
+BraveExternalProcessImporterHost::GetObserverForTesting() {
+  return observer_;
+}
+
+#if BUILDFLAG(ENABLE_EXTENSIONS)
+
+bool BraveExternalProcessImporterHost::NeedToImportExtensions() const {
+  return !cancelled_ && (items_ & user_data_importer::EXTENSIONS) ==
+                            user_data_importer::EXTENSIONS;
+}
+
+void BraveExternalProcessImporterHost::OnExtensionsImportReady(bool ready) {
+  if (cancelled_) {
+    return;
+  }
+  if (!ready) {
+    extensions_importer_.reset();
+    importer::ShowImportLockDialog(
+        parent_view_, parent_window_,
+        base::BindOnce(
+            &BraveExternalProcessImporterHost::OnExtensionsImportLockDialogEnd,
+            weak_ptr_factory_.GetWeakPtr()),
+        IDS_EXTENSIONS_IMPORTER_LOCK_TITLE, IDS_EXTENSIONS_IMPORTER_LOCK_TEXT);
+  } else {
+    extensions_import_ready_ = true;
+    LaunchImportIfReady();
+  }
+}
+
+void BraveExternalProcessImporterHost::OnExtensionsImportLockDialogEnd(
+    bool is_continue) {
+  DCHECK(!extensions_importer_);
+  if (is_continue) {
+    LaunchImportIfReady();
+  } else {
+    NotifyImportEnded();
+  }
+}
+
+void BraveExternalProcessImporterHost::OnExtensionImported(
+    const std::string& extension_id,
+    extensions_import::ExtensionImportStatus status) {
+  if (!extensions_importer_ || !extensions_importer_->IsImportInProgress()) {
+    extensions_importer_.reset();
+    if (observer_) {
+      NotifyImportItemEnded(user_data_importer::EXTENSIONS);
+    }
+    ExternalProcessImporterHost::NotifyImportEnded();
+  }
+}
+
+#endif
--- /dev/null
+++ b/chrome/browser/importer/brave_external_process_importer_host.h
@@ -0,0 +1,66 @@
+/* Copyright (c) 2019 The Brave Authors. All rights reserved.
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this file,
+ * You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef BRAVE_BROWSER_IMPORTER_BRAVE_EXTERNAL_PROCESS_IMPORTER_HOST_H_
+#define BRAVE_BROWSER_IMPORTER_BRAVE_EXTERNAL_PROCESS_IMPORTER_HOST_H_
+
+#include <memory>
+#include <string>
+
+#include "base/gtest_prod_util.h"
+#include "base/memory/weak_ptr.h"
+#include "chrome/browser/importer/external_process_importer_host.h"
+#include "extensions/buildflags/buildflags.h"
+
+#if BUILDFLAG(ENABLE_EXTENSIONS)
+namespace extensions_import {
+class ExtensionsImporter;
+enum class ExtensionImportStatus : int32_t;
+}  // namespace extensions_import
+#endif
+
+class BraveExternalProcessImporterHost : public ExternalProcessImporterHost {
+ public:
+  BraveExternalProcessImporterHost();
+  BraveExternalProcessImporterHost(const BraveExternalProcessImporterHost&) =
+      delete;
+  BraveExternalProcessImporterHost& operator=(
+      const BraveExternalProcessImporterHost&) = delete;
+
+ private:
+  friend class ExternalProcessImporterHost;
+  friend class BraveExternalProcessImporterHostUnitTest;
+
+  FRIEND_TEST_ALL_PREFIXES(BraveImporterObserverUnitTest, ImportEvents);
+  FRIEND_TEST_ALL_PREFIXES(BraveImporterObserverUnitTest, DestroyObserverEarly);
+
+  ~BraveExternalProcessImporterHost() override;
+
+  void DoNotLaunchImportForTesting();
+  void NotifyImportEndedForTesting();
+  importer::ImporterProgressObserver* GetObserverForTesting();
+
+  // ExternalProcessImporterHost overrides:
+  void NotifyImportEnded() override;
+  void LaunchImportIfReady() override;
+
+#if BUILDFLAG(ENABLE_EXTENSIONS)
+  bool NeedToImportExtensions() const;
+
+  void OnExtensionsImportReady(bool ready);
+  void OnExtensionsImportLockDialogEnd(bool is_continue);
+  void OnExtensionImported(const std::string& extension_id,
+                           extensions_import::ExtensionImportStatus status);
+
+  std::unique_ptr<extensions_import::ExtensionsImporter> extensions_importer_;
+  bool extensions_import_ready_ = false;
+#endif
+
+  bool do_not_launch_import_for_testing_ = false;
+  // Vends weak pointers for the importer to call us back.
+  base::WeakPtrFactory<BraveExternalProcessImporterHost> weak_ptr_factory_;
+};
+
+#endif  // BRAVE_BROWSER_IMPORTER_BRAVE_EXTERNAL_PROCESS_IMPORTER_HOST_H_
--- /dev/null
+++ b/chrome/browser/ui/webui/settings/brave_full_disk_access_confirm_dialog_delegate.h
@@ -0,0 +1,44 @@
+/* Copyright (c) 2022 The Brave Authors. All rights reserved.
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this file,
+ * You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef BRAVE_BROWSER_UI_WEBUI_SETTINGS_BRAVE_FULL_DISK_ACCESS_CONFIRM_DIALOG_DELEGATE_H_
+#define BRAVE_BROWSER_UI_WEBUI_SETTINGS_BRAVE_FULL_DISK_ACCESS_CONFIRM_DIALOG_DELEGATE_H_
+
+#include <string>
+
+#include "base/memory/raw_ptr.h"
+#include "chrome/browser/ui/tab_modal_confirm_dialog_delegate.h"
+
+namespace content {
+class WebContents;
+}  // namespace content
+
+class Browser;
+
+class FullDiskAccessConfirmDialogDelegate
+    : public TabModalConfirmDialogDelegate {
+ public:
+  FullDiskAccessConfirmDialogDelegate(content::WebContents* web_contents,
+                                      Browser* browser);
+  ~FullDiskAccessConfirmDialogDelegate() override;
+
+  FullDiskAccessConfirmDialogDelegate(
+      const FullDiskAccessConfirmDialogDelegate&) = delete;
+  FullDiskAccessConfirmDialogDelegate& operator=(
+      const FullDiskAccessConfirmDialogDelegate&) = delete;
+
+ private:
+  // TabModalConfirmDialogDelegate overrides:
+  std::u16string GetTitle() override;
+  std::u16string GetDialogMessage() override;
+  std::u16string GetLinkText() const override;
+  std::u16string GetAcceptButtonTitle() override;
+  void OnAccepted() override;
+  void OnLinkClicked(WindowOpenDisposition disposition) override;
+
+  raw_ptr<Browser> browser_;
+};
+
+#endif  // BRAVE_BROWSER_UI_WEBUI_SETTINGS_BRAVE_FULL_DISK_ACCESS_CONFIRM_DIALOG_DELEGATE_H_
--- /dev/null
+++ b/chrome/browser/ui/webui/settings/brave_full_disk_access_confirm_dialog_delegate_mac.mm
@@ -0,0 +1,62 @@
+/* Copyright (c) 2022 The Brave Authors. All rights reserved.
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this file,
+ * You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "chrome/browser/ui/webui/settings/brave_full_disk_access_confirm_dialog_delegate.h"
+
+#import <AppKit/AppKit.h>
+
+#include "base/functional/bind.h"
+#include "base/values.h"
+#include "chrome/browser/importer/external_process_importer_host.h"
+#include "chrome/browser/ui/browser.h"
+#include "chrome/browser/ui/browser_tabstrip.h"
+#include "chrome/browser/ui/tab_modal_confirm_dialog.h"
+#include "chrome/browser/ui/tab_modal_confirm_dialog_delegate.h"
+#include "chrome/grit/generated_resources.h"
+#include "components/user_data_importer/common/importer_data_types.h"
+#include "content/public/browser/web_ui.h"
+#include "ui/base/l10n/l10n_util.h"
+#include "ui/base/ui_base_types.h"
+#include "url/gurl.h"
+
+FullDiskAccessConfirmDialogDelegate::FullDiskAccessConfirmDialogDelegate(
+    content::WebContents* web_contents,
+    Browser* browser)
+    : TabModalConfirmDialogDelegate(web_contents), browser_(browser) {}
+
+FullDiskAccessConfirmDialogDelegate::~FullDiskAccessConfirmDialogDelegate() =
+    default;
+
+// TODO: figure out l10n
+std::u16string FullDiskAccessConfirmDialogDelegate::GetTitle() {
+  return u"Full Disk Access required";
+}
+
+std::u16string FullDiskAccessConfirmDialogDelegate::GetDialogMessage() {
+  return u"Helium needs Full Disk Access to import your Bookmarks from Safari.";
+}
+
+std::u16string FullDiskAccessConfirmDialogDelegate::GetLinkText() const {
+  return u"Learn how to grant Full Disk Access from your System Preferences.";
+}
+
+std::u16string FullDiskAccessConfirmDialogDelegate::GetAcceptButtonTitle() {
+  return u"Open System Preferences";
+}
+
+void FullDiskAccessConfirmDialogDelegate::OnAccepted() {
+  [[NSWorkspace sharedWorkspace]
+      openURL:[NSURL URLWithString:
+                         @"x-apple.systempreferences:com.apple.preference."
+                         @"security?Privacy_AllFiles"]];  // NOLINT
+}
+
+void FullDiskAccessConfirmDialogDelegate::OnLinkClicked(
+    WindowOpenDisposition disposition) {
+  const int target_index = browser_->tab_strip_model()->active_index() + 1;
+  // Add import help tab right after current settings tab.
+  chrome::AddTabAt(browser_, GURL("https://github.com/imputnet/helium-macos/wiki/Import-data-from-Safari"), target_index,
+                   true /* foreground */);
+}
--- /dev/null
+++ b/chrome/common/importer/chrome_profile_import.mojom
@@ -0,0 +1,26 @@
+/* Copyright (c) 2020 The Brave Authors. All rights reserved.
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this file,
+ * You can obtain one at https://mozilla.org/MPL/2.0/. */
+
+module chrome.mojom;
+
+import "chrome/common/importer/profile_import.mojom";
+import "mojo/public/mojom/base/string16.mojom";
+
+// This interface is used to control the import process.
+interface ChromeProfileImport {
+  // Start the importer. |items| is a bitmask of user_data_importer::ImportItem of items
+  // to import.
+  StartImport(
+      chrome.mojom.SourceProfile source_profile,
+      uint16 items,
+      map<uint32, string> localized_strings,
+      pending_remote<chrome.mojom.ProfileImportObserver> observer);
+
+  // Stop the importer.
+  CancelImport();
+
+  // Tell the importer that we're done with one item.
+  ReportImportItemFinished(chrome.mojom.ImportItem item);
+};
--- /dev/null
+++ b/chrome/browser/importer/brave_in_process_importer_bridge.cc
@@ -0,0 +1,10 @@
+/* Copyright 2020 The Brave Authors. All rights reserved.
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this file,
+ * You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "chrome/browser/importer/brave_in_process_importer_bridge.h"
+
+#include "chrome/browser/importer/profile_writer.h"
+
+BraveInProcessImporterBridge::~BraveInProcessImporterBridge() = default;
--- /dev/null
+++ b/chrome/browser/importer/brave_in_process_importer_bridge.h
@@ -0,0 +1,25 @@
+/* Copyright 2020 The Brave Authors. All rights reserved.
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this file,
+ * You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef BRAVE_BROWSER_IMPORTER_BRAVE_IN_PROCESS_IMPORTER_BRIDGE_H_
+#define BRAVE_BROWSER_IMPORTER_BRAVE_IN_PROCESS_IMPORTER_BRIDGE_H_
+
+#include <string>
+
+#include "chrome/browser/importer/in_process_importer_bridge.h"
+
+class BraveInProcessImporterBridge : public InProcessImporterBridge {
+ public:
+  using InProcessImporterBridge::InProcessImporterBridge;
+
+  BraveInProcessImporterBridge(const BraveInProcessImporterBridge&) = delete;
+  BraveInProcessImporterBridge operator=(
+      const BraveInProcessImporterBridge&) = delete;
+
+ private:
+  ~BraveInProcessImporterBridge() override;
+};
+
+#endif  // BRAVE_BROWSER_IMPORTER_BRAVE_IN_PROCESS_IMPORTER_BRIDGE_H_
--- /dev/null
+++ b/chrome/browser/importer/extensions_import_helpers.cc
@@ -0,0 +1,383 @@
+/* Copyright (c) 2022 The Brave Authors. All rights reserved.
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this file,
+ * You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "chrome/browser/importer/extensions_import_helpers.h"
+
+#include <algorithm>
+#include <memory>
+#include <optional>
+#include <utility>
+
+#include "base/check.h"
+#include "base/check_is_test.h"
+#include "base/check_op.h"
+#include "base/files/file_enumerator.h"
+#include "base/files/file_util.h"
+#include "base/task/sequenced_task_runner.h"
+#include "chrome/common/importer/chrome_importer_utils.h"
+#include "chrome/browser/extensions/webstore_install_with_prompt.h"
+#include "chrome/browser/profiles/profile.h"
+#include "components/value_store/value_store.h"
+#include "components/value_store/value_store_factory.h"
+#include "components/value_store/value_store_factory_impl.h"
+#include "extensions/browser/api/storage/value_store_util.h"
+#include "extensions/browser/extension_file_task_runner.h"
+#include "extensions/browser/extension_registrar.h"
+#include "extensions/browser/extension_registry.h"
+#include "extensions/common/constants.h"
+
+namespace extensions_import {
+
+namespace {
+
+InstallExtensionFnForTesting* g_extension_installer_for_testing = nullptr;
+
+}
+
+// Silent installer via webstore w/o any prompt or bubble.
+class WebstoreInstallerForImporting
+    : public extensions::WebstoreInstallWithPrompt {
+ public:
+  using WebstoreInstallWithPrompt::AbortInstall;
+  using WebstoreInstallWithPrompt::WebstoreInstallWithPrompt;
+
+ private:
+  ~WebstoreInstallerForImporting() override = default;
+
+  std::unique_ptr<ExtensionInstallPrompt::Prompt> CreateInstallPrompt()
+      const override {
+    return nullptr;
+  }
+  bool ShouldShowPostInstallUI() const override { return false; }
+};
+
+base::expected<std::vector<ImportingExtension>, bool> GetExtensionsList(
+    const base::FilePath& source_profile,
+    const base::FilePath& target_profile) {
+  std::vector<ImportingExtension> result;
+  const auto extensions = GetImportableChromeExtensionsList(source_profile);
+  if (!extensions || extensions->empty()) {
+    return base::ok(std::move(result));
+  }
+
+  auto source_store_factory =
+      base::MakeRefCounted<value_store::ValueStoreFactoryImpl>(source_profile);
+
+  for (const auto& extension_id : *extensions) {
+    const auto value_store =
+        base::FilePath(extensions::kLocalExtensionSettingsDirectoryName)
+            .AppendASCII(extension_id);
+
+    bool has_local_settings = false;
+
+    if (source_store_factory->HasValueStore(
+            base::FilePath(extensions::kLocalExtensionSettingsDirectoryName)
+                .AppendASCII(extension_id))) {
+      auto store = extensions::value_store_util::CreateSettingsStore(
+          extensions::settings_namespace::LOCAL,
+          extensions::value_store_util::ModelType::EXTENSION, extension_id,
+          source_store_factory);
+      const auto settings = store->Get();
+      if (!settings.status().ok()) {
+        if (!settings.status().IsCorrupted()) {
+          return base::unexpected(false);
+        }
+      } else {
+        has_local_settings = true;
+      }
+    }
+    ImportingExtension e;
+    e.id = extension_id;
+    e.has_local_settings = has_local_settings;
+    result.push_back(std::move(e));
+  }
+
+  return base::ok(std::move(result));
+}
+
+bool ImportLocalExtensionSettings(const std::string& extension_id,
+                                  const base::FilePath& source_profile,
+                                  const base::FilePath& target_profile) {
+  auto source_store_factory =
+      base::MakeRefCounted<value_store::ValueStoreFactoryImpl>(source_profile);
+  auto source_store = extensions::value_store_util::CreateSettingsStore(
+      extensions::settings_namespace::LOCAL,
+      extensions::value_store_util::ModelType::EXTENSION, extension_id,
+      source_store_factory);
+
+  auto settings = source_store->Get();
+  if (!settings.status().ok()) {
+    return false;
+  }
+
+  auto target_store_factory =
+      base::MakeRefCounted<value_store::ValueStoreFactoryImpl>(target_profile);
+
+  // First delete the settings in the target profile because we are going to
+  // overwrite them from the source profile.
+  extensions::value_store_util::DeleteValueStore(
+      extensions::settings_namespace::LOCAL,
+      extensions::value_store_util::ModelType::EXTENSION, extension_id,
+      target_store_factory);
+
+  auto target_store = extensions::value_store_util::CreateSettingsStore(
+      extensions::settings_namespace::LOCAL,
+      extensions::value_store_util::ModelType::EXTENSION, extension_id,
+      target_store_factory);
+
+  const auto result = target_store->Set(value_store::ValueStore::DEFAULTS,
+                                        settings.PassSettings());
+  return result.status().ok();
+}
+
+bool ImportIndexedDBExtensionSettings(const std::string& extension_id,
+                                      const base::FilePath& source_profile,
+                                      const base::FilePath& target_profile) {
+  constexpr char kIndexedDBDir[] = "IndexedDB";
+
+  const base::FilePath pattern = base::FilePath::FromASCII(
+      base::StrCat({"chrome-extension_", extension_id, "_*indexeddb*"}));
+
+  base::FileEnumerator target_enumerator(
+      target_profile.AppendASCII(kIndexedDBDir), false,
+      base::FileEnumerator::DIRECTORIES, pattern.value());
+  // Clear the target profile.
+  target_enumerator.ForEach(
+      [](const base::FilePath& path) { base::DeletePathRecursively(path); });
+
+  base::FileEnumerator source_enumerator(
+      source_profile.AppendASCII(kIndexedDBDir), false,
+      base::FileEnumerator::DIRECTORIES, pattern.value());
+  // Copy settings.
+  source_enumerator.ForEach([&target_profile,
+                             &kIndexedDBDir](const base::FilePath& path) {
+    base::CreateDirectory(target_profile.AppendASCII(kIndexedDBDir));
+    base::CopyDirectory(
+        path, target_profile.AppendASCII(kIndexedDBDir).Append(path.BaseName()),
+        true);
+  });
+
+  return true;
+}
+
+bool ImportExtensionSettings(const std::string& extension_id,
+                             const base::FilePath& source_profile,
+                             const base::FilePath& target_profile) {
+  if (!ImportLocalExtensionSettings(extension_id, source_profile,
+                                    target_profile)) {
+    return false;
+  }
+  if (!ImportIndexedDBExtensionSettings(extension_id, source_profile,
+                                        target_profile)) {
+    return false;
+  }
+  return true;
+}
+
+ImportingExtension::ImportingExtension() = default;
+ImportingExtension::ImportingExtension(ImportingExtension&&) = default;
+ImportingExtension& ImportingExtension::operator=(ImportingExtension&&) =
+    default;
+
+ImportingExtension::~ImportingExtension() {
+  if (installer) {
+    installer->AbortInstall();
+  }
+}
+
+ExtensionsImporter::ExtensionsImporter(const base::FilePath& source_profile,
+                                       Profile* target_profile)
+    : source_profile_(source_profile), target_profile_(target_profile) {
+  CHECK(target_profile_);
+  CHECK_NE(source_profile_, target_profile_->GetPath());
+}
+
+ExtensionsImporter::~ExtensionsImporter() = default;
+
+void ExtensionsImporter::Prepare(OnReady on_ready) {
+  CHECK(extensions_.empty());
+  extensions::GetExtensionFileTaskRunner()->PostTaskAndReplyWithResult(
+      FROM_HERE,
+      base::BindOnce(&GetExtensionsList, source_profile_,
+                     target_profile_->GetPath()),
+      base::BindOnce(&ExtensionsImporter::OnGetExtensionsForImport,
+                     weak_factory_.GetWeakPtr(), std::move(on_ready)));
+}
+
+bool ExtensionsImporter::Import(OnExtensionImported on_extension) {
+  CHECK(!IsImportInProgress());
+
+  if (extensions_.empty()) {
+    return false;
+  }
+
+  in_progress_count_ = extensions_.size();
+  for (auto& extension : extensions_) {
+    if (extension.is_installed) {
+      // Force tests to fail if |this| is deleted while enumerating extensions.
+      DCHECK(weak_factory_.GetWeakPtr());
+      --in_progress_count_;
+      on_extension.Run(extension.id, ExtensionImportStatus::kOk);
+      continue;
+    }
+
+    auto done_callback = base::BindOnce(
+        [](base::WeakPtr<ExtensionsImporter> self, OnExtensionImported callback,
+           const std::string& id, ExtensionImportStatus status) {
+          if (self) {
+            --self->in_progress_count_;
+            callback.Run(id, status);
+          }
+        },
+        weak_factory_.GetWeakPtr(), on_extension);
+
+    StartExtensionInstall(extension, std::move(done_callback));
+  }
+
+  return true;
+}
+
+const ImportingExtension* ExtensionsImporter::GetExtension(
+    const std::string& id) const {
+  auto fnd = std::ranges::find(extensions_, id, &ImportingExtension::id);
+  if (fnd == extensions_.end()) {
+    return nullptr;
+  }
+  return &(*fnd);
+}
+
+bool ExtensionsImporter::IsImportInProgress() const {
+  return in_progress_count_ > 0;
+}
+
+// static [[nodiscard]]
+base::AutoReset<InstallExtensionFnForTesting*>
+ExtensionsImporter::OverrideExtensionInstallerForTesting(
+    InstallExtensionFnForTesting* installer) {
+  base::AutoReset result(&g_extension_installer_for_testing, installer);
+  return result;
+}
+
+void ExtensionsImporter::StartExtensionInstall(
+    ImportingExtension& extension,
+    base::OnceCallback<void(const std::string& id,
+                            ExtensionImportStatus status)> done_callback) {
+  if (!g_extension_installer_for_testing) {
+    // In production, start installation from the Web Store.
+    extension.installer = base::MakeRefCounted<WebstoreInstallerForImporting>(
+        extension.id, target_profile_, /*parent_window=*/gfx::NativeWindow(),
+        base::BindOnce(&ExtensionsImporter::OnExtensionInstalled,
+                       weak_factory_.GetWeakPtr(), extension.id,
+                       std::move(done_callback)));
+    extension.installer->BeginInstall();
+  } else {
+    // In tests, we don't have access to the Web Store and we already know the
+    // installation result from test expectations, so we emulate an async
+    // installation process.
+    CHECK_IS_TEST();
+    const auto status = g_extension_installer_for_testing->Run(extension.id);
+    base::SequencedTaskRunner::GetCurrentDefault()->PostTask(
+        FROM_HERE,
+        base::BindOnce(&ExtensionsImporter::OnExtensionInstalled,
+                       weak_factory_.GetWeakPtr(), extension.id,
+                       std::move(done_callback),
+                       status == ExtensionImportStatus::kOk, "",
+                       extensions::webstore_install::Result::SUCCESS));
+  }
+}
+
+ImportingExtension* ExtensionsImporter::FindExtension(const std::string& id) {
+  auto fnd = std::ranges::find(extensions_, id, &ImportingExtension::id);
+  if (fnd == extensions_.end()) {
+    return nullptr;
+  }
+  return &(*fnd);
+}
+
+void ExtensionsImporter::OnGetExtensionsForImport(OnReady on_ready,
+                                                  ExtensionsListResult result) {
+  if (!result.has_value()) {
+    return std::move(on_ready).Run(false);
+  }
+  extensions_ = std::move(result).value();
+
+  auto* registry = extensions::ExtensionRegistry::Get(target_profile_);
+  for (auto& extension : extensions_) {
+    extension.is_installed =
+        registry->GetInstalledExtension(extension.id) != nullptr;
+  }
+
+  std::move(on_ready).Run(true);
+}
+
+void ExtensionsImporter::OnExtensionInstalled(
+    const std::string& extension_id,
+    OnOneExtensionImported on_extension,
+    bool success,
+    const std::string& error,
+    extensions::webstore_install::Result result) {
+  auto* extension = FindExtension(extension_id);
+  if (!extension) {
+    return std::move(on_extension)
+        .Run(extension_id, ExtensionImportStatus::kFailedToInstall);
+  }
+
+  extension->is_installed = success;
+  extension->installer.reset();
+
+  if (!success) {
+    return std::move(on_extension)
+        .Run(extension->id, ExtensionImportStatus::kFailedToInstall);
+  }
+
+  if (!extension->has_local_settings) {
+    return std::move(on_extension)
+        .Run(extension->id, ExtensionImportStatus::kOk);
+  }
+  extensions::ExtensionRegistrar::Get(target_profile_)
+      ->DisableExtension(extension->id,
+                         {extensions::disable_reason::DISABLE_RELOAD});
+  ImportExtensionSettings(extension->id, std::move(on_extension));
+}
+
+void ExtensionsImporter::ImportExtensionSettings(
+    const std::string& extension_id,
+    OnOneExtensionImported on_extension) {
+  auto* extension = FindExtension(extension_id);
+  if (!extension) {
+    return std::move(on_extension)
+        .Run(extension->id, ExtensionImportStatus::kFailedToImportSettings);
+  }
+  CHECK(extension->has_local_settings);
+  extensions::GetExtensionFileTaskRunner()->PostTaskAndReplyWithResult(
+      FROM_HERE,
+      base::BindOnce(&extensions_import::ImportExtensionSettings, extension->id,
+                     source_profile_, target_profile_->GetPath()),
+      base::BindOnce(&ExtensionsImporter::OnExtensionSettingsImported,
+                     weak_factory_.GetWeakPtr(), extension->id,
+                     std::move(on_extension)));
+}
+
+void ExtensionsImporter::OnExtensionSettingsImported(
+    const std::string& extension_id,
+    OnOneExtensionImported on_extension,
+    bool success) {
+  auto* extension = FindExtension(extension_id);
+  if (!extension) {
+    return std::move(on_extension)
+        .Run(extension->id, ExtensionImportStatus::kFailedToImportSettings);
+  }
+  extensions::ExtensionRegistrar::Get(target_profile_)
+      ->EnableExtension(extension->id);
+
+  if (!success) {
+    return std::move(on_extension)
+        .Run(extension->id, ExtensionImportStatus::kFailedToImportSettings);
+  }
+
+  std::move(on_extension).Run(extension->id, ExtensionImportStatus::kOk);
+}
+
+}  // namespace extensions_import
--- /dev/null
+++ b/chrome/browser/importer/extensions_import_helpers.h
@@ -0,0 +1,104 @@
+/* Copyright (c) 2022 The Brave Authors. All rights reserved.
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this file,
+ * You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef BRAVE_BROWSER_IMPORTER_EXTENSIONS_IMPORT_HELPERS_H_
+#define BRAVE_BROWSER_IMPORTER_EXTENSIONS_IMPORT_HELPERS_H_
+
+#include <string>
+#include <vector>
+
+#include "base/auto_reset.h"
+#include "base/files/file_path.h"
+#include "base/functional/callback_forward.h"
+#include "base/memory/raw_ptr.h"
+#include "base/memory/weak_ptr.h"
+#include "base/types/expected.h"
+#include "chrome/common/extensions/webstore_install_result.h"
+
+class Profile;
+
+namespace extensions_import {
+
+struct ImportingExtension {
+  ImportingExtension();
+  ImportingExtension(ImportingExtension&&);
+  ImportingExtension& operator=(ImportingExtension&&);
+  ~ImportingExtension();
+
+  std::string id;
+  bool is_installed = false;
+  bool has_local_settings = false;
+  scoped_refptr<class WebstoreInstallerForImporting> installer;
+};
+
+enum class ExtensionImportStatus : int32_t {
+  kOk = 0,
+  kFailedToInstall,
+  kFailedToImportSettings,
+};
+
+using InstallExtensionFnForTesting =
+    base::RepeatingCallback<ExtensionImportStatus(
+        const std::string& extension_id)>;
+
+class ExtensionsImporter {
+ public:
+  using OnReady = base::OnceCallback<void(bool ready)>;
+  using OnExtensionImported =
+      base::RepeatingCallback<void(const std::string& id,
+                                   ExtensionImportStatus status)>;
+
+  ExtensionsImporter(const base::FilePath& source_profile,
+                     Profile* target_profile);
+  ~ExtensionsImporter();
+
+  void Prepare(OnReady on_ready);
+  bool Import(OnExtensionImported on_extension);
+
+  const ImportingExtension* GetExtension(const std::string& id) const;
+  bool IsImportInProgress() const;
+
+  [[nodiscard]] static base::AutoReset<InstallExtensionFnForTesting*>
+  OverrideExtensionInstallerForTesting(InstallExtensionFnForTesting* installer);
+
+ private:
+  using ExtensionsListResult =
+      base::expected<std::vector<ImportingExtension>, bool>;
+  using OnOneExtensionImported =
+      base::OnceCallback<void(const std::string& id,
+                              ExtensionImportStatus status)>;
+
+  void StartExtensionInstall(
+      ImportingExtension& extension,
+      base::OnceCallback<void(const std::string& id,
+                              ExtensionImportStatus status)> done_callback);
+
+  ImportingExtension* FindExtension(const std::string& id);
+
+  void OnGetExtensionsForImport(OnReady on_ready, ExtensionsListResult result);
+  void OnExtensionInstalled(const std::string& extension_id,
+                            OnOneExtensionImported on_extension,
+                            bool success,
+                            const std::string& error,
+                            extensions::webstore_install::Result result);
+
+  void ImportExtensionSettings(const std::string& extension_id,
+                               OnOneExtensionImported on_extension);
+  void OnExtensionSettingsImported(const std::string& extension_id,
+                                   OnOneExtensionImported on_extension,
+                                   bool success);
+
+  const base::FilePath source_profile_;
+  raw_ptr<Profile> target_profile_ = nullptr;
+
+  std::vector<ImportingExtension> extensions_;
+  size_t in_progress_count_ = 0;
+
+  base::WeakPtrFactory<ExtensionsImporter> weak_factory_{this};
+};
+
+}  // namespace extensions_import
+
+#endif  // BRAVE_BROWSER_IMPORTER_EXTENSIONS_IMPORT_HELPERS_H_
--- /dev/null
+++ b/chrome/utility/importer/brave_profile_import_impl.cc
@@ -0,0 +1,144 @@
+/* Copyright (c) 2020 The Brave Authors. All rights reserved.
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this file,
+ * You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "chrome/utility/importer/brave_profile_import_impl.h"
+
+#include <memory>
+#include <utility>
+
+#include "base/check.h"
+#include "base/command_line.h"
+#include "base/functional/bind.h"
+#include "base/location.h"
+#include "base/memory/ref_counted.h"
+#include "base/notreached.h"
+#include "base/task/single_thread_task_runner.h"
+#include "base/threading/thread.h"
+#include "chrome/utility/importer/brave_external_process_importer_bridge.h"
+#include "chrome/utility/importer/chrome_importer.h"
+#include "build/build_config.h"
+#include "chrome/common/importer/profile_import.mojom.h"
+#include "chrome/utility/importer/external_process_importer_bridge.h"
+#include "chrome/utility/importer/importer.h"
+#include "components/user_data_importer/common/importer_type.h"
+#include "content/public/utility/utility_thread.h"
+#include "mojo/public/cpp/bindings/remote.h"
+#include "mojo/public/cpp/bindings/shared_remote.h"
+
+namespace {
+
+scoped_refptr<Importer> CreateImporterByType(
+    user_data_importer::ImporterType type) {
+  switch (type) {
+    case user_data_importer::TYPE_CHROME:
+      return new ChromeImporter();
+    case user_data_importer::TYPE_EDGE_CHROMIUM:
+      return new ChromeImporter();
+    case user_data_importer::TYPE_VIVALDI:
+      return new ChromeImporter();
+    case user_data_importer::TYPE_OPERA:
+      return new ChromeImporter();
+    case user_data_importer::TYPE_YANDEX:
+      return new ChromeImporter();
+    case user_data_importer::TYPE_WHALE:
+      return new ChromeImporter();
+    case user_data_importer::TYPE_ARC:
+      return new ChromeImporter();
+    case user_data_importer::TYPE_DIA:
+      return new ChromeImporter();
+    case user_data_importer::TYPE_PERPLEXITY_COMET:
+      return new ChromeImporter();
+    case user_data_importer::TYPE_BRAVE:
+      return new ChromeImporter();
+    default:
+      break;
+  }
+  NOTREACHED() << "All handled for supported types above.";
+}
+
+}  // namespace
+
+BraveProfileImportImpl::BraveProfileImportImpl(
+    mojo::PendingReceiver<chrome::mojom::ChromeProfileImport> receiver)
+    : receiver_(this, std::move(receiver)) {}
+
+BraveProfileImportImpl::~BraveProfileImportImpl() = default;
+
+void BraveProfileImportImpl::StartImport(
+    const user_data_importer::SourceProfile& source_profile,
+    uint16_t items,
+    const base::flat_map<uint32_t, std::string>& localized_strings,
+    mojo::PendingRemote<chrome::mojom::ProfileImportObserver> observer) {
+  // Signal change to OSCrypt password for importing from Chrome/Chromium
+  base::CommandLine* command_line = base::CommandLine::ForCurrentProcess();
+  if (source_profile.importer_name.starts_with(u"Chrome")) {
+    command_line->AppendSwitch("import-chrome");
+  } else if (source_profile.importer_type ==
+             user_data_importer::TYPE_EDGE_CHROMIUM) {
+    command_line->AppendSwitch("import-edge");
+  } else if (source_profile.importer_name.starts_with(u"Chromium")) {
+    command_line->AppendSwitch("import-chromium");
+  } else if (source_profile.importer_type == user_data_importer::TYPE_OPERA) {
+    command_line->AppendSwitch("import-opera");
+  } else if (source_profile.importer_type == user_data_importer::TYPE_YANDEX) {
+    command_line->AppendSwitch("import-yandex");
+  } else if (source_profile.importer_type == user_data_importer::TYPE_WHALE) {
+    command_line->AppendSwitch("import-whale");
+  } else if (source_profile.importer_type == user_data_importer::TYPE_ARC) {
+    command_line->AppendSwitch("import-arc");
+  } else if (source_profile.importer_type == user_data_importer::TYPE_DIA) {
+    command_line->AppendSwitch("import-dia");
+  } else if (source_profile.importer_type == user_data_importer::TYPE_PERPLEXITY_COMET) {
+    command_line->AppendSwitch("import-perplexity-comet");
+  } else if (source_profile.importer_type == user_data_importer::TYPE_BRAVE) {
+    command_line->AppendSwitch("import-brave");
+  } else if (source_profile.importer_type == user_data_importer::TYPE_VIVALDI) {
+    command_line->AppendSwitch("import-vivaldi");
+  }
+
+  content::UtilityThread::Get()->EnsureBlinkInitialized();
+  importer_ = CreateImporterByType(source_profile.importer_type);
+  if (!importer_.get()) {
+    mojo::Remote<chrome::mojom::ProfileImportObserver>(std::move(observer))
+        ->OnImportFinished(false, "Importer could not be created.");
+    return;
+  }
+
+  items_to_import_ = items;
+
+  // Create worker thread in which importer runs.
+  import_thread_ = std::make_unique<base::Thread>("import_thread");
+#if BUILDFLAG(IS_WIN)
+  import_thread_->init_com_with_mta(false);
+#endif
+  CHECK(import_thread_->Start());
+  bridge_ = new BraveExternalProcessImporterBridge(
+      localized_strings,
+      mojo::SharedRemote<chrome::mojom::ProfileImportObserver>(
+          std::move(observer)));
+  import_thread_->task_runner()->PostTask(
+      FROM_HERE,
+      base::BindOnce(&Importer::StartImport, importer_, source_profile, items,
+                     base::RetainedRef(bridge_)));
+}
+
+void BraveProfileImportImpl::CancelImport() {
+  ImporterCleanup();
+}
+
+void BraveProfileImportImpl::ReportImportItemFinished(
+    user_data_importer::ImportItem item) {
+  items_to_import_ ^= item;  // Remove finished item from mask.
+  if (items_to_import_ == 0) {
+    ImporterCleanup();
+  }
+}
+
+void BraveProfileImportImpl::ImporterCleanup() {
+  importer_->Cancel();
+  importer_.reset();
+  bridge_.reset();
+  import_thread_.reset();
+}
--- /dev/null
+++ b/chrome/utility/importer/brave_profile_import_impl.h
@@ -0,0 +1,64 @@
+/* Copyright (c) 2020 The Brave Authors. All rights reserved.
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this file,
+ * You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef BRAVE_UTILITY_IMPORTER_BRAVE_PROFILE_IMPORT_IMPL_H_
+#define BRAVE_UTILITY_IMPORTER_BRAVE_PROFILE_IMPORT_IMPL_H_
+
+#include <memory>
+#include <string>
+
+#include "chrome/common/importer/chrome_profile_import.mojom.h"
+#include "mojo/public/cpp/bindings/pending_receiver.h"
+#include "mojo/public/cpp/bindings/pending_remote.h"
+#include "mojo/public/cpp/bindings/receiver.h"
+
+class BraveExternalProcessImporterBridge;
+class Importer;
+
+namespace base {
+class Thread;
+}  // namespace base
+
+namespace importer {
+struct SourceProfile;
+}  // namespace importer
+
+class BraveProfileImportImpl : public chrome::mojom::ChromeProfileImport {
+ public:
+  explicit BraveProfileImportImpl(
+      mojo::PendingReceiver<chrome::mojom::ChromeProfileImport> receiver);
+  ~BraveProfileImportImpl() override;
+
+  BraveProfileImportImpl(const BraveProfileImportImpl&) = delete;
+  BraveProfileImportImpl& operator=(const BraveProfileImportImpl&) = delete;
+
+ private:
+  // chrome::mojom::ChromeProfileImport overrides:
+  void StartImport(
+      const user_data_importer::SourceProfile& source_profile,
+      uint16_t items,
+      const base::flat_map<uint32_t, std::string>& localized_strings,
+      mojo::PendingRemote<chrome::mojom::ProfileImportObserver> observer)
+      override;
+  void CancelImport() override;
+  void ReportImportItemFinished(user_data_importer::ImportItem item) override;
+
+  void ImporterCleanup();
+
+  mojo::Receiver<chrome::mojom::ChromeProfileImport> receiver_;
+  std::unique_ptr<base::Thread> import_thread_;
+
+  // Bridge object is passed to importer, so that it can send IPC calls
+  // directly back to the ProfileImportProcessHost.
+  scoped_refptr<BraveExternalProcessImporterBridge> bridge_;
+
+  // A bitmask of user_data_importer::ImportItem.
+  uint16_t items_to_import_ = 0;
+
+  // Importer of the appropriate type (Firefox, Safari, IE, etc.)
+  scoped_refptr<Importer> importer_;
+};
+
+#endif  // BRAVE_UTILITY_IMPORTER_BRAVE_PROFILE_IMPORT_IMPL_H_
--- /dev/null
+++ b/chrome/utility/importer/brave_external_process_importer_bridge.cc
@@ -0,0 +1,17 @@
+/* Copyright 2020 The Brave Authors. All rights reserved.
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this file,
+ * You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "chrome/utility/importer/brave_external_process_importer_bridge.h"
+
+#include <utility>
+
+BraveExternalProcessImporterBridge::BraveExternalProcessImporterBridge(
+    const base::flat_map<uint32_t, std::string>& localized_strings,
+    mojo::SharedRemote<chrome::mojom::ProfileImportObserver> observer)
+    : ExternalProcessImporterBridge(std::move(localized_strings),
+                                         std::move(observer)) {}
+
+BraveExternalProcessImporterBridge::
+    ~BraveExternalProcessImporterBridge() = default;
--- /dev/null
+++ b/chrome/utility/importer/brave_external_process_importer_bridge.h
@@ -0,0 +1,29 @@
+/* Copyright 2020 The Brave Authors. All rights reserved.
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this file,
+ * You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef BRAVE_UTILITY_IMPORTER_BRAVE_EXTERNAL_PROCESS_IMPORTER_BRIDGE_H_
+#define BRAVE_UTILITY_IMPORTER_BRAVE_EXTERNAL_PROCESS_IMPORTER_BRIDGE_H_
+
+#include <string>
+
+#include "chrome/common/importer/chrome_profile_import.mojom.h"
+#include "chrome/utility/importer/external_process_importer_bridge.h"
+
+class BraveExternalProcessImporterBridge : public ExternalProcessImporterBridge {
+ public:
+  BraveExternalProcessImporterBridge(
+      const base::flat_map<uint32_t, std::string>& localized_strings,
+      mojo::SharedRemote<chrome::mojom::ProfileImportObserver> observer);
+
+  BraveExternalProcessImporterBridge(
+      const BraveExternalProcessImporterBridge&) = delete;
+  BraveExternalProcessImporterBridge& operator=(
+      const BraveExternalProcessImporterBridge&) = delete;
+
+ private:
+  ~BraveExternalProcessImporterBridge() override;
+};
+
+#endif  // BRAVE_UTILITY_IMPORTER_BRAVE_EXTERNAL_PROCESS_IMPORTER_BRIDGE_H_
--- /dev/null
+++ b/chrome/utility/importer/chrome_importer.cc
@@ -0,0 +1,437 @@
+/* Copyright (c) 2019 The Brave Authors. All rights reserved.
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this file,
+ * You can obtain one at https://mozilla.org/MPL/2.0/. */
+
+#include "chrome/utility/importer/chrome_importer.h"
+
+#include <memory>
+#include <optional>
+#include <string>
+#include <utility>
+
+#include "base/files/file_util.h"
+#include "base/json/json_reader.h"
+#include "base/logging.h"
+#include "base/memory/ref_counted.h"
+#include "base/strings/utf_string_conversions.h"
+#include "chrome/common/importer/scoped_copy_file.h"
+#include "chrome/utility/importer/brave_external_process_importer_bridge.h"
+#include "build/build_config.h"
+#include "chrome/common/importer/importer_bridge.h"
+#include "chrome/grit/generated_resources.h"
+#include "components/os_crypt/sync/os_crypt.h"
+#include "components/password_manager/core/browser/password_form.h"
+#include "components/password_manager/core/browser/password_store/login_database.h"
+#include "components/password_manager/core/common/password_manager_pref_names.h"
+#include "components/prefs/json_pref_store.h"
+#include "components/prefs/pref_filter.h"
+#include "components/user_data_importer/content/favicon_reencode.h"
+#include "components/user_data_importer/common/imported_bookmark_entry.h"
+#include "components/user_data_importer/common/importer_data_types.h"
+#include "components/user_data_importer/common/importer_url_row.h"
+#include "components/webdata/common/webdata_constants.h"
+#include "sql/database.h"
+#include "sql/statement.h"
+#include "ui/base/l10n/l10n_util.h"
+#include "ui/base/page_transition_types.h"
+#include "url/gurl.h"
+
+#if BUILDFLAG(IS_LINUX)
+#include "chrome/grit/branded_strings.h"
+#include "components/os_crypt/sync/key_storage_config_linux.h"
+#endif  // BUILDFLAG(IS_LINUX)
+
+#if BUILDFLAG(IS_WIN)
+#include "base/base64.h"
+#include "base/win/wincrypt_shim.h"
+#endif
+
+using base::Time;
+
+namespace {
+
+// Most of below code is copied from os_crypt_win.cc
+#if BUILDFLAG(IS_WIN)
+// Contains base64 random key encrypted with DPAPI.
+constexpr char kOsCryptEncryptedKeyPrefName[] = "os_crypt.encrypted_key";
+
+// Key prefix for a key encrypted with DPAPI.
+constexpr char kDPAPIKeyPrefix[] = "DPAPI";
+
+bool DecryptStringWithDPAPI(const std::string& ciphertext,
+                            std::string* plaintext) {
+  DATA_BLOB input;
+  input.pbData =
+      const_cast<BYTE*>(reinterpret_cast<const BYTE*>(ciphertext.data()));
+  input.cbData = static_cast<DWORD>(ciphertext.length());
+
+  DATA_BLOB output;
+  BOOL result = CryptUnprotectData(&input, nullptr, nullptr, nullptr, nullptr,
+                                   0, &output);
+  if (!result) {
+    PLOG(ERROR) << "Failed to decrypt";
+    return false;
+  }
+
+  plaintext->assign(reinterpret_cast<char*>(output.pbData), output.cbData);
+  LocalFree(output.pbData);
+  return true;
+}
+
+// Return false if encryption key setting is failed.
+// Fetch chrome's raw encryption key and use it to get chrome's password data.
+bool SetEncryptionKeyForPasswordImporting(
+    const base::FilePath& local_state_path) {
+  std::string local_state_content;
+  base::ReadFileToString(local_state_path, &local_state_content);
+  std::optional<base::Value::Dict> local_state =
+      base::JSONReader::ReadDict(local_state_content,
+                                 base::JSON_PARSE_CHROMIUM_EXTENSIONS);
+  if (!local_state) {
+    return false;
+  }
+
+  if (auto* base64_encrypted_key =
+          local_state->FindStringByDottedPath(kOsCryptEncryptedKeyPrefName)) {
+    std::string encrypted_key_with_header;
+
+    base::Base64Decode(*base64_encrypted_key, &encrypted_key_with_header);
+
+    if (!encrypted_key_with_header.starts_with(kDPAPIKeyPrefix)) {
+      return false;
+    }
+    std::string encrypted_key =
+        encrypted_key_with_header.substr(sizeof(kDPAPIKeyPrefix) - 1);
+    std::string key;
+    // This DPAPI decryption can fail if the user's password has been reset
+    // by an Administrator.
+    if (DecryptStringWithDPAPI(encrypted_key, &key)) {
+      OSCrypt::SetRawEncryptionKey(key);
+      return true;
+    }
+  }
+  return false;
+}
+#endif
+
+[[maybe_unused]]
+bool SetEncryptionKey(const base::FilePath& source_path) {
+#if BUILDFLAG(IS_LINUX)
+  // Set up crypt config.
+  std::unique_ptr<os_crypt::Config> config(new os_crypt::Config());
+  config->product_name = l10n_util::GetStringUTF8(IDS_PRODUCT_NAME);
+  config->should_use_preference = false;
+  config->user_data_path = source_path;
+  OSCrypt::SetConfig(std::move(config));
+  return true;
+#elif BUILDFLAG(IS_WIN)
+  base::FilePath local_state_path = source_path.Append(
+      base::FilePath::StringType(FILE_PATH_LITERAL("Local State")));
+  if (!base::PathExists(local_state_path))
+    return false;
+  if (!SetEncryptionKeyForPasswordImporting(local_state_path))
+    return false;
+  return true;
+#else
+  return true;
+#endif
+}
+
+[[maybe_unused]]
+bool PasswordFormToImportedPasswordForm(
+    const password_manager::PasswordForm& form,
+    user_data_importer::ImportedPasswordForm& imported_form) {
+  if (form.scheme != password_manager::PasswordForm::Scheme::kHtml &&
+      form.scheme != password_manager::PasswordForm::Scheme::kBasic) {
+    return false;
+  }
+
+  if (form.scheme == password_manager::PasswordForm::Scheme::kHtml) {
+    imported_form.scheme =
+        user_data_importer::ImportedPasswordForm::Scheme::kHtml;
+  } else {
+    imported_form.scheme =
+        user_data_importer::ImportedPasswordForm::Scheme::kBasic;
+  }
+
+  if (form.blocked_by_user &&
+      (!form.username_value.empty() || !form.password_value.empty())) {
+    return false;
+  }
+
+  imported_form.signon_realm = form.signon_realm;
+  imported_form.url = form.url;
+  imported_form.action = form.action;
+  imported_form.username_element = form.username_element;
+  imported_form.username_value = form.username_value;
+  imported_form.password_element = form.password_element;
+  imported_form.password_value = form.password_value;
+  imported_form.blocked_by_user = form.blocked_by_user;
+  return true;
+}
+
+}  // namespace
+
+ChromeImporter::ChromeImporter() = default;
+
+ChromeImporter::~ChromeImporter() = default;
+
+void ChromeImporter::StartImport(
+    const user_data_importer::SourceProfile& source_profile,
+    uint16_t items,
+    ImporterBridge* bridge) {
+  bridge_ = bridge;
+  source_path_ = source_profile.source_path;
+  importer_name_ = source_profile.importer_name;
+  // The order here is important!
+  bridge_->NotifyStarted();
+
+  if ((items & user_data_importer::HISTORY) && !cancelled()) {
+    bridge_->NotifyItemStarted(user_data_importer::HISTORY);
+    ImportHistory();
+    bridge_->NotifyItemEnded(user_data_importer::HISTORY);
+  }
+
+  if ((items & user_data_importer::FAVORITES) && !cancelled()) {
+    bridge_->NotifyItemStarted(user_data_importer::FAVORITES);
+    ImportBookmarks();
+    bridge_->NotifyItemEnded(user_data_importer::FAVORITES);
+  }
+
+#if BUILDFLAG(IS_WIN)
+  auto source_path =
+      source_profile.importer_type == user_data_importer::TYPE_OPERA
+          ? source_path_
+          : source_path_.DirName();
+#else
+  auto source_path = source_path_;
+#endif
+  bridge_->NotifyEnded();
+}
+
+void ChromeImporter::ImportHistory() {
+  base::FilePath history_path = source_path_.Append(
+      base::FilePath::StringType(FILE_PATH_LITERAL("History")));
+  if (!base::PathExists(history_path))
+    return;
+
+  ScopedCopyFile copy_history_file(history_path);
+  if (!copy_history_file.copy_success())
+    return;
+
+  sql::Database db(sql::Database::Tag("History"));
+  if (!db.Open(copy_history_file.copied_file_path())) {
+    return;
+  }
+
+  const char query[] =
+      "SELECT u.url, u.title, v.visit_time, u.typed_count, u.visit_count "
+      "FROM urls u JOIN visits v ON u.id = v.url "
+      "WHERE hidden = 0 "
+      "AND (transition & ?) != 0 "              // CHAIN_END
+      "AND (transition & ?) NOT IN (?, ?, ?)";  // No SUBFRAME or
+                                                // KEYWORD_GENERATED
+
+  sql::Statement s(db.GetUniqueStatement(query));
+  s.BindInt64(0, ui::PAGE_TRANSITION_CHAIN_END);
+  s.BindInt64(1, ui::PAGE_TRANSITION_CORE_MASK);
+  s.BindInt64(2, ui::PAGE_TRANSITION_AUTO_SUBFRAME);
+  s.BindInt64(3, ui::PAGE_TRANSITION_MANUAL_SUBFRAME);
+  s.BindInt64(4, ui::PAGE_TRANSITION_KEYWORD_GENERATED);
+
+  std::vector<user_data_importer::ImporterURLRow> rows;
+  while (s.Step() && !cancelled()) {
+    GURL url(s.ColumnString(0));
+
+    user_data_importer::ImporterURLRow row(url);
+    row.title = s.ColumnString16(1);
+    row.last_visit = base::Time::FromSecondsSinceUnixEpoch(
+        chromeTimeToDouble((s.ColumnInt64(2))));
+    row.hidden = false;
+    row.typed_count = s.ColumnInt(3);
+    row.visit_count = s.ColumnInt(4);
+
+    rows.push_back(row);
+  }
+
+  if (!rows.empty() && !cancelled())
+    bridge_->SetHistoryItems(rows,
+                             user_data_importer::VISIT_SOURCE_CHROME_IMPORTED);
+}
+
+void ChromeImporter::ImportBookmarks() {
+  std::string bookmarks_content;
+  base::FilePath bookmarks_path = source_path_.Append(
+      base::FilePath::StringType(FILE_PATH_LITERAL("Bookmarks")));
+  ScopedCopyFile copy_bookmark_file(bookmarks_path);
+  if (!copy_bookmark_file.copy_success())
+    return;
+
+  base::ReadFileToString(copy_bookmark_file.copied_file_path(),
+                         &bookmarks_content);
+  std::optional<base::Value::Dict> bookmark_dict =
+      base::JSONReader::ReadDict(bookmarks_content,
+                                 base::JSON_PARSE_CHROMIUM_EXTENSIONS);
+  if (!bookmark_dict)
+    return;
+
+  std::vector<user_data_importer::ImportedBookmarkEntry> bookmarks;
+  const base::Value::Dict* roots = bookmark_dict->FindDict("roots");
+  if (roots) {
+    // Importing bookmark bar items
+    const base::Value::Dict* bookmark_bar = roots->FindDict("bookmark_bar");
+    if (bookmark_bar) {
+      std::vector<std::u16string> path;
+      const auto* name = bookmark_bar->FindString("name");
+
+      path.push_back(base::UTF8ToUTF16(name ? *name : std::string()));
+      RecursiveReadBookmarksFolder(bookmark_bar, path, true, &bookmarks);
+    }
+    // Importing other items
+    const base::Value::Dict* other = roots->FindDict("other");
+    if (other) {
+      std::vector<std::u16string> path;
+      const auto* name = other->FindString("name");
+
+      path.push_back(base::UTF8ToUTF16(name ? *name : std::string()));
+      RecursiveReadBookmarksFolder(other, path, false, &bookmarks);
+    }
+  }
+  // Write into profile.
+  if (!bookmarks.empty() && !cancelled()) {
+    bridge_->AddBookmarks(
+        bookmarks, l10n_util::GetStringFUTF16(IDS_IMPORTED_FROM_BOOKMARK_FOLDER,
+                                              importer_name_));
+  }
+
+  // Import favicons.
+  base::FilePath favicons_path = source_path_.Append(
+      base::FilePath::StringType(FILE_PATH_LITERAL("Favicons")));
+  if (!base::PathExists(favicons_path))
+    return;
+
+  ScopedCopyFile copy_favicon_file(favicons_path);
+  if (!copy_favicon_file.copy_success())
+    return;
+
+  sql::Database db(sql::Database::Tag("Favicons"));
+  if (!db.Open(copy_favicon_file.copied_file_path()))
+    return;
+
+  FaviconMap favicon_map;
+  ImportFaviconURLs(&db, &favicon_map);
+  // Write favicons into profile.
+  if (!favicon_map.empty() && !cancelled()) {
+    favicon_base::FaviconUsageDataList favicons;
+    LoadFaviconData(&db, favicon_map, &favicons);
+    bridge_->SetFavicons(favicons);
+  }
+}
+
+void ChromeImporter::ImportFaviconURLs(sql::Database* db,
+                                       FaviconMap* favicon_map) {
+  const char query[] = "SELECT icon_id, page_url FROM icon_mapping;";
+  sql::Statement s(db->GetUniqueStatement(query));
+
+  while (s.Step() && !cancelled()) {
+    int64_t icon_id = s.ColumnInt64(0);
+    GURL url = GURL(s.ColumnString(1));
+    (*favicon_map)[icon_id].insert(url);
+  }
+}
+
+void ChromeImporter::LoadFaviconData(
+    sql::Database* db,
+    const FaviconMap& favicon_map,
+    favicon_base::FaviconUsageDataList* favicons) {
+  const char query[] =
+      "SELECT f.url, fb.image_data "
+      "FROM favicons f "
+      "JOIN favicon_bitmaps fb "
+      "ON f.id = fb.icon_id "
+      "WHERE f.id = ?;";
+  sql::Statement s(db->GetUniqueStatement(query));
+
+  if (!s.is_valid())
+    return;
+
+  for (const auto& entry : favicon_map) {
+    s.BindInt64(0, entry.first);
+    if (s.Step()) {
+      favicon_base::FaviconUsageData usage;
+
+      usage.favicon_url = GURL(s.ColumnString(0));
+      if (!usage.favicon_url.is_valid())
+        continue;  // Don't bother importing favicons with invalid URLs.
+
+      std::vector<uint8_t> data;
+      s.ColumnBlobAsVector(1, &data);
+      if (data.empty())
+        continue;  // Data definitely invalid.
+
+      auto decoded_data = importer::ReencodeFavicon(base::span(data));
+      if (!decoded_data) {
+        continue;  // Unable to decode.
+      }
+
+      usage.urls = entry.second;
+      usage.png_data = std::move(decoded_data).value();
+      favicons->push_back(usage);
+    }
+    s.Reset(true);
+  }
+}
+
+void ChromeImporter::RecursiveReadBookmarksFolder(
+    const base::Value::Dict* folder,
+    const std::vector<std::u16string>& parent_path,
+    bool is_in_toolbar,
+    std::vector<user_data_importer::ImportedBookmarkEntry>* bookmarks) {
+  const base::Value::List* children = folder->FindList("children");
+  if (children) {
+    for (const auto& value : *children) {
+      const base::Value::Dict* dict = value.GetIfDict();
+      if (!dict)
+        continue;
+      const auto* date_added = dict->FindString("date_added");
+      const auto* name_found = dict->FindString("name");
+      auto name = base::UTF8ToUTF16(name_found ? *name_found : std::string());
+      const auto* type = dict->FindString("type");
+      const auto* url = dict->FindString("url");
+      user_data_importer::ImportedBookmarkEntry entry;
+      if (type && *type == "folder") {
+        // Folders are added implicitly on adding children, so we only
+        // explicitly add empty folders.
+        const base::Value::List* inner_children = dict->FindList("children");
+        if (inner_children && inner_children->empty()) {
+          entry.in_toolbar = is_in_toolbar;
+          entry.is_folder = true;
+          entry.url = GURL();
+          entry.path = parent_path;
+          entry.title = name;
+          entry.creation_time = base::Time::FromSecondsSinceUnixEpoch(
+              chromeTimeToDouble(std::stoll(*date_added)));
+          bookmarks->push_back(entry);
+        }
+
+        std::vector<std::u16string> path = parent_path;
+        path.push_back(name);
+        RecursiveReadBookmarksFolder(dict, path, is_in_toolbar, bookmarks);
+      } else if (type && *type == "url") {
+        entry.in_toolbar = is_in_toolbar;
+        entry.is_folder = false;
+        entry.url = GURL(*url);
+        entry.path = parent_path;
+        entry.title = name;
+        entry.creation_time = base::Time::FromSecondsSinceUnixEpoch(
+            chromeTimeToDouble(std::stoll(*date_added)));
+        bookmarks->push_back(entry);
+      }
+    }
+  }
+}
+
+double ChromeImporter::chromeTimeToDouble(int64_t time) {
+  return ((time * 10 - 0x19DB1DED53E8000) / 10000) / 1000;
+}
--- /dev/null
+++ b/chrome/utility/importer/chrome_importer.h
@@ -0,0 +1,76 @@
+/* Copyright (c) 2019 The Brave Authors. All rights reserved.
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this file,
+ * You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef BRAVE_UTILITY_IMPORTER_CHROME_IMPORTER_H_
+#define BRAVE_UTILITY_IMPORTER_CHROME_IMPORTER_H_
+
+#include <stdint.h>
+
+#include <map>
+#include <set>
+#include <string>
+#include <vector>
+
+#include "base/compiler_specific.h"
+#include "base/files/file_path.h"
+#include "base/nix/xdg_util.h"
+#include "base/values.h"
+#include "build/build_config.h"
+#include "chrome/utility/importer/importer.h"
+#include "components/favicon_base/favicon_usage_data.h"
+
+namespace user_data_importer {
+struct ImportedBookmarkEntry;
+}  // namespace user_data_importer
+
+namespace sql {
+class Database;
+}
+
+class ChromeImporter : public Importer {
+ public:
+  ChromeImporter();
+  ChromeImporter(const ChromeImporter&) = delete;
+  ChromeImporter& operator=(const ChromeImporter&) = delete;
+
+  // Importer:
+  void StartImport(const user_data_importer::SourceProfile& source_profile,
+                   uint16_t items,
+                   ImporterBridge* bridge) override;
+
+ protected:
+  ~ChromeImporter() override;
+
+  void ImportBookmarks();
+  void ImportHistory();
+
+  double chromeTimeToDouble(int64_t time);
+
+  base::FilePath source_path_;
+
+ private:
+  // Multiple URLs can share the same favicon; this is a map
+  // of URLs -> IconIDs that we load as a temporary step before
+  // actually loading the icons.
+  typedef std::map<int64_t, std::set<GURL>> FaviconMap;
+
+  // Loads the urls associated with the favicons into favicon_map;
+  void ImportFaviconURLs(sql::Database* db, FaviconMap* favicon_map);
+
+  // Loads and reencodes the individual favicons.
+  void LoadFaviconData(sql::Database* db,
+                       const FaviconMap& favicon_map,
+                       favicon_base::FaviconUsageDataList* favicons);
+
+  void RecursiveReadBookmarksFolder(
+      const base::Value::Dict* folder,
+      const std::vector<std::u16string>& parent_path,
+      bool is_in_toolbar,
+      std::vector<user_data_importer::ImportedBookmarkEntry>* bookmarks);
+
+  std::u16string importer_name_;
+};
+
+#endif  // BRAVE_UTILITY_IMPORTER_CHROME_IMPORTER_H_
